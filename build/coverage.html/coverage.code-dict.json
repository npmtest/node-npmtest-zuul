{"/home/travis/build/npmtest/node-npmtest-zuul/test.js":"/* istanbul instrument in package npmtest_zuul */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-zuul/lib.npmtest_zuul.js":"/* istanbul instrument in package npmtest_zuul */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_zuul = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_zuul = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-zuul/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-zuul && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_zuul */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_zuul\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_zuul.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_zuul.rollup.js'] =\n            local.assetsDict['/assets.npmtest_zuul.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_zuul.__dirname + '/lib.npmtest_zuul.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/zuul.js":"var debug = require('debug')('zuul');\nvar omit = require('lodash').omit;\nvar open = require('opener');\nvar Batch = require('batch');\nvar EventEmitter = require('events').EventEmitter;\n\nvar control_app = require('./control-app');\nvar frameworks = require('../frameworks');\nvar setup_test_instance = require('./setup');\nvar SauceBrowser = require('./SauceBrowser');\nvar PhantomBrowser = require('./PhantomBrowser');\nvar Electron = require('./Electron');\n\nmodule.exports = Zuul;\n\nfunction Zuul(config) {\n    if (!(this instanceof Zuul)) {\n        return new Zuul(config);\n    }\n\n    if (config.browser_retries === undefined) {\n        config.browser_retries = 6;\n    }\n\n    if (config.browser_output_timeout === undefined) {\n        config.browser_output_timeout = -1;\n    }\n\n   if (config.browser_open_timeout === undefined) {\n       config.browser_open_timeout = 120 * 1000;\n   }\n\n    var self = this;\n\n    var ui = config.ui;\n    var framework_dir = frameworks[ui];\n    if (!framework_dir) {\n        throw new Error('unsupported ui: ' + ui);\n    }\n\n    config.framework_dir = framework_dir;\n    self._config = config;\n\n    debug('config: %j', omit(config, ['sauce_username', 'sauce_key', 'username', 'key']));\n\n    // list of browsers to test\n    self._browsers = [];\n\n    self._concurrency = config.concurrency || 5;\n}\n\nZuul.prototype.__proto__ = EventEmitter.prototype;\n\nZuul.prototype._setup = function(cb) {\n    var self = this;\n\n    var config = self._config;\n\n    // we only need one control app\n    var control_server = control_app(config).listen(0, function() {\n        debug('control server active on port %d', control_server.address().port);\n        cb(null, control_server.address().port);\n    });\n};\n\nZuul.prototype.browser = function(info) {\n    var self = this;\n    var config = self._config;\n\n    self._browsers.push(SauceBrowser({\n        name: config.name,\n        build: process.env.TRAVIS_BUILD_NUMBER,\n        firefox_profile: info.firefox_profile,\n        username: config.username,\n        key: config.key,\n        browser: info.name,\n        version: info.version,\n        platform: info.platform,\n        capabilities: config.capabilities\n    }, config));\n};\n\nZuul.prototype.run = function(done) {\n    var self = this;\n\n    var config = self._config;\n\n    self._setup(function(err, control_port) {\n        config.control_port = control_port;\n\n        if (config.local) {\n            setup_test_instance(config, function(err, url) {\n                if (err) {\n                    console.error(err.stack);\n                    process.exit(1);\n                    return;\n                }\n\n                if (config.open) {\n                    open(url);\n                }\n                else {\n                    console.log('open the following url in a browser:');\n                    console.log(url);\n                }\n            });\n            return;\n        }\n\n        // TODO love and care\n        if (config.phantom) {\n            var phantom = PhantomBrowser(config);\n            self.emit('browser', phantom);\n            phantom.once('done', function(results) {\n                done(results.failed === 0 && results.passed > 0);\n            });\n            return phantom.start();\n        }\n\n        if (config.electron) {\n            var electron = Electron(config);\n            self.emit('browser', electron);\n            electron.once('done', function(results) {\n                done(results.failed === 0 && results.passed > 0);\n            });\n            return electron.start();\n        }\n\n        var batch = new Batch();\n        batch.concurrency(self._concurrency);\n\n        var passed = true;\n\n        self._browsers.forEach(function(browser) {\n            self.emit('browser', browser);\n\n            var retries = config.browser_retries;\n\n            browser.on('error', function(err) {\n                if (--retries >= 0) {\n                    debug('browser error (%s), restarting', err.message)\n                    self.emit('restart', browser);\n                    return browser.start();\n                }\n\n                self.emit('error', err);\n            });\n\n            batch.push(function(done) {\n                browser.once('done', function(results) {\n                    // if no tests passed, then this is also a problem\n                    // indicates potential error to even run tests\n                    if (results.failed || results.passed === 0) {\n                        passed = false;\n                    }\n                    done();\n                });\n                browser.start();\n            });\n        });\n\n        batch.end(function(err) {\n            debug('batch done');\n            done(err || passed);\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/control-app.js":"var path = require('path');\nvar fs = require('fs');\nvar deglob = require('globs-to-files');\n\nvar compression = require('compression');\nvar express = require('express');\nvar expstate = require('express-state');\nvar browserify = require('browserify');\nvar im = require('istanbul-middleware');\nvar watchify = require('watchify');\nvar assign = require('lodash').assign;\nvar humanizeDuration = require('humanize-duration');\nvar debug = require('debug')('zuul:control-app');\n\nvar defaultBuilder = '../lib/builder-browserify';\n\nmodule.exports = function(config) {\n    var files = config.files;\n    var ui = config.ui;\n    var framework_dir = config.framework_dir;\n    var prj_dir = config.prj_dir;\n\n    var opt = {\n        debug: true\n    };\n\n    // watchify options\n    // https://github.com/substack/watchify#var-w--watchifyb-opts\n    opt = assign(opt, {\n        cache: {},\n        packageCache: {},\n        fullPaths: true\n    });\n\n    files = deglob.sync(files, {cwd: prj_dir});\n\n    var user_html = '';\n    if (config.html) {\n        user_html = fs.readFileSync(path.join(prj_dir, config.html), 'utf-8');\n    }\n\n    var build;\n    // default builder is browserify which we provide\n    config.builder = config.builder || defaultBuilder;\n\n    build = require(config.builder)(files, config);\n\n    var app = express();\n    app.use(compression());\n\n    expstate.extend(app);\n\n    app.set('state namespace', 'zuul');\n    app.expose(ui, 'ui');\n    app.expose(config.name, 'title');\n\n    app.set('views', __dirname + '/../frameworks');\n    app.set('view engine', 'html');\n    app.engine('html', require('hbs').__express);\n\n    app.use(function(req, res, next) {\n        res.locals.title = config.name;\n        res.locals.user_scripts = config.scripts || [];\n        res.locals.user_html = user_html;\n        next();\n    });\n\n    app.use(app.router);\n\n    var bundle_router = new express.Router();\n\n    app.use(bundle_router.middleware);\n\n    // zuul files\n    app.use('/__zuul', express.static(__dirname + '/../frameworks'));\n    // framework files\n    app.use('/__zuul', express.static(framework_dir));\n\n    // any user's files\n    app.use(express.static(process.cwd()));\n\n    if (config.coverage && config.local) {\n        // coverage endpoint\n        app.use('/__zuul/coverage', im.createHandler());\n    }\n\n    app.get('/__zuul', function(req, res) {\n        res.locals.config = { port: config.support_port };\n        res.render('index');\n    });\n\n    var map = undefined;\n\n    var clientBundler = browserify(opt);\n    clientBundler.require(path.join(framework_dir, '/client.js'), { entry: true });\n\n    // we use watchify to speed up `.bundle()` calls\n    clientBundler = watchify(clientBundler);\n\n    bundle_router.get('/__zuul/client.js', function(req, res, next) {\n        res.contentType('application/javascript');\n\n        var start = Date.now();\n        clientBundler.bundle(function(err, buf) {\n            if (err) {\n                return next(err);\n            }\n\n            debug('zuul client took %s to bundle', humanizeDuration(Date.now() - start));\n\n            res.send(buf.toString());\n        });\n    });\n\n    bundle_router.get('/__zuul/test-bundle.map.json', function(req, res, next) {\n        if (!map) {\n            return res.status(404).send('');\n        }\n\n        res.json(map);\n    });\n\n    bundle_router.get('/__zuul/test-bundle.js', function(req, res, next) {\n        res.contentType('application/javascript');\n\n        build(function(err, src, srcmap) {\n            if (err) {\n                return next(err);\n            }\n\n            if (srcmap) {\n                map = srcmap;\n                map.file = '/__zuul/test-bundle.js';\n                src += '//# sourceMappingURL=' + '/__zuul/test-bundle.map.json';\n            }\n\n            res.send(src);\n        });\n    });\n\n    return app;\n};\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/index.js":"module.exports.qunit = __dirname + '/qunit';\nmodule.exports.tape = __dirname + '/tape';\nmodule.exports.jasmine = __dirname + '/jasmine';\nmodule.exports.jasmine2 = __dirname + '/jasmine2';\nmodule.exports['mocha-bdd'] = __dirname + '/mocha';\nmodule.exports['mocha-tdd'] = __dirname + '/mocha';\nmodule.exports['mocha-qunit'] = __dirname + '/mocha';\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/setup.js":"var http = require('http');\nvar httpProxy = require('http-proxy');\nvar debug = require('debug')('zuul:setup');\n\nvar user_server = require('./user-server');\n\n// sets up a test instance\n// cb(err, instance)\n// instance.shutdown() terminates the instance\nfunction setup_test_instance(opt, cb) {\n\n    var support_server = undefined;\n    var bouncer = undefined;\n    var Tunnel;\n    if (typeof opt.tunnel === 'string') {\n        Tunnel = require('zuul-' + opt.tunnel);\n        debug('using zuul-%s to tunnel', opt.tunnel);\n    } else if (typeof opt.tunnel === 'object' && opt.tunnel.type) {\n        Tunnel = require('zuul-' + opt.tunnel.type);\n        debug('using zuul-%s to tunnel', opt.tunnel.type);\n    } else {\n        Tunnel = require('zuul-localtunnel');\n        debug('using zuul-localhost to tunnel');\n    }\n\n    var tunnel = new Tunnel(opt);\n\n    if (opt.server) {\n        user_server(opt.server, setup);\n    }\n    else {\n        setup();\n    }\n\n    function setup(_support_server) {\n        support_server = _support_server;\n        var config = opt;\n        var control_port = opt.control_port;\n\n        var support_port = undefined;\n        if (support_server) {\n            support_port = config.support_port = support_server.port;\n        }\n\n        // TODO start support server\n        // currently happens within user_server\n\n        var bouncer_port = 0;\n        if (config.local && parseInt(config.local)) {\n            bouncer_port = config.local;\n        }\n\n        if (config.phantom && parseInt(config.phantom)) {\n            bouncer_port = config.phantom;\n        }\n\n        var proxy = httpProxy.createProxy();\n        proxy.on('proxyReq', on_proxy_req);\n\n        bouncer = http.createServer();\n        bouncer.on('request', on_request(proxy.web));\n        bouncer.on('upgrade', on_request(proxy.ws));\n\n        function on_request(bounce) {\n            return function(req, res) {\n                var args = [].slice.call(arguments);\n                if (is_control_req(req)) {\n                    args.push({ target: 'http://localhost:' + control_port });\n                    bounce.apply(proxy, args);\n                    return;\n                }\n\n                args.push({ target: 'http://localhost:' + support_port }, on_support_server_proxy_done);\n                bounce.apply(proxy, args);\n            };\n        }\n\n        function on_proxy_req(proxyReq, req, res, options) {\n            if (is_control_req(req) ||\n                (req.headers.connection && req.headers.connection.toLowerCase().indexOf('upgrade') === -1)) {\n                proxyReq.setHeader('connection', 'close');\n            }\n        }\n\n        function on_support_server_proxy_done(err, req, res) {\n            if (err.code === 'ECONNRESET' && res && res.socket && res.socket.destroyed === true) {\n                debug('Request to support-server:%s was canceled by the client, ignoring the proxy error');\n            }\n        }\n\n        function is_control_req(req) {\n            var url = req.url.split('?')[0];\n            return !support_port || url.split('/')[1] === '__zuul';\n        }\n\n        bouncer.listen(bouncer_port, bouncer_active);\n\n        function bouncer_active() {\n            var app_port = bouncer.address().port;\n            debug('bouncer active on port %d', app_port);\n\n            if (!config.tunnel) {\n                return cb(null, 'http://localhost:' + app_port + '/__zuul');\n            }\n\n            tunnel.connect(app_port, cb);\n        };\n    }\n\n    function shutdown() {\n        bouncer.close();\n        tunnel.close();\n\n        if (support_server) {\n            support_server.process.kill('SIGKILL');\n        }\n    }\n\n    return {\n        shutdown: shutdown\n    };\n}\n\nmodule.exports = setup_test_instance;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/user-server.js":"var spawn = require('child_process').spawn;\n\nvar http = require('http');\nvar copy = require('shallow-copy');\nvar parse_cmd = require('shell-quote').parse;\nvar debug = require('debug')('zuul:user-server');\n\nmodule.exports = function(server, callback) {\n    debug('user server: %s', server);\n\n    var cmd;\n    var cwd;\n    var wait = 0;\n    if (server !== null && server.cmd) {\n        // expect the following format in .zuul.yml\n        // server:\n        //   cmd: ./test/support/server.js\n        //   cwd: ./anotherapp\n        cmd = server.cmd;\n        cwd = server.cwd;\n        wait = server.wait;\n    }\n    else {\n        // expect the following format in .zuul.yml\n        // server: ./test/support/server.js\n        cmd = server;\n    }\n\n    if (!cwd) {\n        // TODO(shtylman) is this right?\n        cwd = process.cwd();\n    }\n\n    var env = copy(process.env);\n\n    get_open_port(function(port) {\n        if (!Array.isArray(cmd)) {\n            cmd = parse_cmd(cmd, { ZUUL_PORT: port });\n        }\n\n        if (/\\.js$/.test(cmd[0])) {\n            cmd.unshift(process.execPath);\n        }\n\n        env.ZUUL_PORT = port;\n\n        debug('user server port %d', port);\n\n        var ps = spawn(cmd[0], cmd.slice(1), { cwd: cwd, env: env });\n        ps.stdout.pipe(process.stdout);\n        ps.stderr.pipe(process.stderr);\n\n        function exit() {\n            ps.kill('SIGTERM');\n        }\n\n        ps.once('exit', function (code) {\n            debug('user server exited with status: %d', code);\n            process.removeListener('exit', exit);\n        });\n\n        process.on('exit', exit);\n\n        return setTimeout(function(){\n            callback({ port: port, process: ps });\n        }, wait);\n    });\n};\n\nfunction get_open_port(callback) {\n    var server  = http.createServer();\n    server.listen(0);\n    server.on('listening', function() {\n        var port = server.address().port;\n        server.close(function() {\n            callback(port);\n        });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/SauceBrowser.js":"var wd = require('wd');\nvar EventEmitter = require('events').EventEmitter;\nvar FirefoxProfile = require('firefox-profile');\nvar debug = require('debug');\nvar omit = require('lodash').omit;\nvar xtend = require('xtend');\nvar _ = require('lodash');\n\n\nvar setup_test_instance = require('./setup');\n\nfunction SauceBrowser(conf, opt) {\n    if (!(this instanceof SauceBrowser)) {\n        return new SauceBrowser(conf, opt);\n    }\n\n    var self = this;\n    self._conf = conf;\n    self._opt = opt;\n    self._opt.tunnel = (opt.sauce_connect) ? false : (self._opt.tunnel || true);\n    self.stats = {\n        passed: 0,\n        failed: 0\n    };\n    self.debug = debug('zuul:sauce:' + conf.browser + ':' + conf.version);\n    self.debug('browser conf: %j', omit(conf, ['username', 'key']));\n}\n\nSauceBrowser.prototype.__proto__ = EventEmitter.prototype;\n\nSauceBrowser.prototype.toString = function() {\n    var self = this;\n    var conf = self._conf;\n    return '<' + conf.browser + ' ' + conf.version + ' on ' + conf.platform + '>';\n};\n\nSauceBrowser.prototype.start = function() {\n    var self = this;\n    var conf = self._conf;\n\n    self.stopped = false;\n    self.stats = {\n        passed: 0,\n        failed: 0\n    };\n\n    self.debug('running');\n    var browser = self.browser = wd.remote('ondemand.saucelabs.com', 80, conf.username, conf.key);\n\n    self.controller = setup_test_instance(self._opt, function(err, url) {\n        if (err) {\n            return self.shutdown(err);\n        }\n\n        self.emit('init', conf);\n\n        var init_conf = xtend({\n            build: conf.build,\n            name: conf.name,\n            tags: conf.tags || [],\n            browserName: conf.browser,\n            version: conf.version,\n            platform: conf.platform\n        }, conf.capabilities);\n\n        // use the SAUCE_APPIUM_VERSION environment variable to specify the\n        // Appium version. If not specified the test will run against the\n        // default Appium version\n        if (process.env.SAUCE_APPIUM_VERSION) {\n            init_conf['appium-version'] = process.env.SAUCE_APPIUM_VERSION;\n        }\n\n        // configures sauce connect with a tunnel identifier\n        // if sauce_connect is true, use the TRAVIS_JOB_NUMBER environment variable\n        // otherwise use the contents of the sauce_connect variable\n        if (self._opt.sauce_connect) {\n            var tunnelId = self._opt.sauce_connect !== true ? self._opt.sauce_connect : process.env.TRAVIS_JOB_NUMBER;\n            if (tunnelId) {\n                init_conf['tunnel-identifier'] = tunnelId;\n            }\n        }\n\n        if (conf.firefox_profile) {\n            var fp = new FirefoxProfile();\n            var extensions = conf.firefox_profile.extensions;\n            for (var preference in conf.firefox_profile) {\n                if (preference !== 'extensions') {\n                    fp.setPreference(preference, conf.firefox_profile[preference]);\n                }\n            }\n            extensions = extensions ? extensions : [];\n            fp.addExtensions(extensions, function () {\n                fp.encoded(function(zippedProfile) {\n                    init_conf.firefox_profile = zippedProfile;\n                    init();\n                });\n            });\n        } else {\n            init();\n        }\n\n        function init() {\n            self.debug('queuing');\n\n            browser.init(init_conf, function(err) {\n                if (err) {\n                    if (err.data) {\n                        err.message += ': ' + err.data.split('\\n').slice(0, 1);\n                    }\n                    return self.shutdown(err);\n                }\n\n                var reporter = new EventEmitter();\n\n                reporter.on('test_end', function(test) {\n                    if (!test.passed) {\n                        return self.stats.failed++;\n                    }\n                    self.stats.passed++;\n                });\n\n                reporter.on('done', function(results) {\n                    clearTimeout(self.noOutputTimeout);\n                    self.debug('done');\n                    var passed = results.passed;\n                    var called = false;\n                    browser.sauceJobStatus(passed, function(err) {\n                        if (called) {\n                            return;\n                        }\n\n                        called = true;\n                        self.shutdown();\n\n                        if (err) {\n                            return;\n                            // don't let this error fail us\n                        }\n                    });\n\n                    reporter.removeAllListeners();\n                });\n\n                self.debug('open %s', url);\n                self.emit('start', reporter);\n\n                var timeout = false;\n                var get_timeout = setTimeout(function() {\n                    self.debug('timed out waiting for open %s', url);\n                    timeout = true;\n                    self.shutdown(new Error('Timeout opening url after ' + Math.round(self._opt.browser_open_timeout/1000) + 's'));\n                }, self._opt.browser_open_timeout);\n\n                browser.get(url, function(err) {\n                    self.debug('browser opened url');\n\n                    if (timeout) {\n                        return;\n                    }\n\n                    clearTimeout(get_timeout);\n                    if (err) {\n                        return self.shutdown(err);\n                    }\n\n                    // no new output for 30s => error\n                    watchOutput();\n\n                    function watchOutput() {\n                        if (self._opt.browser_output_timeout === -1) {\n                            return;\n                        }\n\n                        clearTimeout(self.noOutputTimeout);\n\n                        self.noOutputTimeout = setTimeout(function() {\n                            self.shutdown(new Error('Did not receive any new output from browser for ' + Math.round(self._opt.browser_output_timeout/1000) + 's, shutting down'));\n                        }, self._opt.browser_output_timeout);\n                    }\n\n                    (function wait() {\n                        if (self.stopped) {\n                            return;\n                        }\n\n                        self.debug('waiting for test results from %s', url);\n                        // take the last 1000 log lines\n                        // careful, the less you log lines, the slower your test\n                        // result will be. The test could be finished in the browser\n                        // but not in your console since it can take a lot\n                        // of time to get a lot of results\n                        var js = '(window.zuul_msg_bus ? window.zuul_msg_bus.splice(0, 1000) : []);'\n                        browser.eval(js, function(err, res) {\n                            if (err) {\n                                self.debug('err: %s', err.message);\n                                return self.shutdown(err);\n                            }\n\n                            res = res || [];\n                            //When testing with microsoft edge:\n                            //Adds length property to array-like object if not defined to execute filter properly\n                            if (res.length === undefined) {\n                                res.length = Object.keys(res).length;\n                            }\n                            self.debug('res.length: %s', res.length);\n\n                            // if we received some data, reset the no output watch timeout\n                            if (res.length > 0) {\n                                watchOutput();\n                            }\n\n                            var has_done = false;\n                            Array.prototype.filter.call(res, Boolean).forEach(function(msg) {\n                                if (msg.type === 'done') {\n                                    has_done = true;\n                                }\n\n                                reporter.emit(msg.type, msg);\n                            });\n\n                            if (has_done) {\n                                self.debug('finished tests for %s', url);\n                                return;\n                            }\n\n                            self.debug('fetching more results');\n\n                            // if we found results, let's not wait\n                            // to get more\n                            if (res.length > 0) {\n                                process.nextTick(wait);\n                            } else {\n                                // otherwise, let's wait a little so that we do not\n                                // spam saucelabs\n                                setTimeout(wait, 2000);\n                            }\n                        });\n                    })();\n                });\n            });\n        }\n    });\n};\n\nSauceBrowser.prototype.shutdown = function(err) {\n    var self = this;\n\n    clearTimeout(self.noOutputTimeout);\n\n    self.stopped = true;\n\n    var finish_shutdown = function () {\n        self.debug('shutdown');\n\n        if (self.controller) {\n            self.controller.shutdown();\n        }\n\n        if (err) {\n            // prefix browser err message with browser version\n            err.message = self._conf.browser + '@' + self._conf.version + ': ' + err.message;\n            self.emit('error', err);\n            return;\n        }\n\n        self.emit('done', self.stats);\n        self.removeAllListeners();\n    }\n\n    // make sure the browser shuts down before continuing\n    if (self.browser) {\n        self.debug('quitting browser');\n\n        var timeout = false;\n        var quit_timeout = setTimeout(function() {\n            self.debug('timed out waiting for browser to quit');\n            timeout = true;\n            finish_shutdown();\n        }, 10 * 1000);\n\n        self.browser.quit(function(err) {\n            if (timeout) {\n                return;\n            }\n\n            clearTimeout(quit_timeout);\n            finish_shutdown();\n        });\n    }\n    else {\n        finish_shutdown();\n    }\n};\n\nmodule.exports = SauceBrowser;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/PhantomBrowser.js":"var spawn = require('child_process').spawn;\nvar path = require('path');\nvar EventEmitter = require('events').EventEmitter;\nvar Split = require('char-split');\nvar debug = require('debug')('zuul:phantombrowser');\n\nvar setup_test_instance = require('./setup');\nrequire('colors');\n\nfunction getPhantom() {\n    try {\n        return require('phantomjs-prebuilt');\n    } catch (e1) {\n        try {\n            // fall back to older package\n            return require('phantomjs');\n        } catch (e2) {\n            // warn users to install phantomjs-prebuilt if they have neither installed\n            throw e1;\n        }\n    }\n}\n\nfunction PhantomBrowser(opt) {\n    if (!(this instanceof PhantomBrowser)) {\n        return new PhantomBrowser(opt);\n    }\n\n    var self = this;\n    self._opt = opt;\n    self.status = {\n        passed: 0,\n        failed: 0\n    };\n}\n\nPhantomBrowser.prototype.__proto__ = EventEmitter.prototype;\n\nPhantomBrowser.prototype.start = function() {\n    var self = this;\n\n    var phantomjs = getPhantom();\n    \n    var binpath = phantomjs.path;\n\n    self.controller = setup_test_instance(self._opt, function(err, url) {\n        if (err) {\n            self.emit('error', err);\n            self.emit('done', {\n                passed: false\n            });\n        }\n\n        debug('url %s', url);\n\n        var reporter = new EventEmitter();\n\n        reporter.on('console', function(msg) {\n            console.log.apply(console, msg.args);\n        });\n\n        reporter.on('test', function(test) {\n            console.log('starting', test.name.white);\n        });\n\n        reporter.on('test_end', function(test) {\n            if (!test.passed) {\n                console.log('failed', test.name.red);\n                return self.status.failed++;\n            }\n\n            console.log('passed:', test.name.green);\n            self.status.passed++;\n        });\n\n        reporter.on('assertion', function(assertion) {\n            console.log('Error: %s'.red, assertion.message);\n            assertion.frames.forEach(function(frame) {\n                console.log('    %s %s:%d'.grey, frame.func, frame.filename, frame.line);\n            });\n            console.log();\n        });\n\n        reporter.on('done', function() {\n            reporter.removeAllListeners();\n        });\n\n        self.emit('init', url);\n        self.emit('start', reporter);\n\n        var debugArgs = [\n            self._opt.phantomRemoteDebuggerPort ? '--remote-debugger-port=' + self._opt.phantomRemoteDebuggerPort : '',\n            self._opt.phantomRemoteDebuggerAutorun ? '--remote-debugger-autorun=true' : ''\n        ].filter(Boolean);\n\n        var args = debugArgs.concat([path.join(__dirname, 'phantom-run.js'), url]);\n        var cp = spawn(binpath, args);\n\n        var split = Split();\n        split.on('data', function(line) {\n            var msg;\n            try {\n                msg = JSON.parse(line);\n            } catch (err) {\n                self.emit('error', new Error('failed to parse json: ' + line));\n                return;\n            }\n\n            debug('msg: %j', msg);\n\n            if (msg.type === 'exception') {\n                self.emit('error', new Error(msg.message));\n            } else {\n                reporter.emit(msg.type, msg);\n            }\n        });\n\n        cp.stdout.setEncoding('utf8');\n        cp.stdout.pipe(split);\n\n        cp.stderr.on('data', function (data) {\n            console.error('phantom stderr: '.red + data);\n        });\n\n        cp.on('close', function (code) {\n            self.emit('done', {\n                passed: self.status.passed,\n                failed: self.status.failed\n            });\n        });\n    });\n};\n\nPhantomBrowser.prototype.shutdown = function() {\n    if (self.controller) {\n        self.controller.shutdown();\n    }\n};\n\nmodule.exports = PhantomBrowser;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/Electron.js":"var spawn = require('child_process').spawn;\nvar path = require('path');\nvar EventEmitter = require('events').EventEmitter;\nvar Split = require('char-split');\nvar debug = require('debug')('zuul:electron');\n\nvar setup_test_instance = require('./setup');\nrequire('colors');\n\nfunction Electron(opt) {\n    if (!(this instanceof Electron)) {\n        return new Electron(opt);\n    }\n\n    var self = this;\n    self._opt = opt;\n    self.status = {\n        passed: 0,\n        failed: 0\n    };\n}\n\nElectron.prototype.__proto__ = EventEmitter.prototype;\n\nElectron.prototype.start = function() {\n    var self = this;\n\n    var binpath;\n    try {\n        binpath = require('electron-prebuilt');\n    } catch (err) {\n        binpath = require('electron');\n    }\n\n    self.controller = setup_test_instance(self._opt, function(err, url) {\n        if (err) {\n            self.emit('error', err);\n            self.emit('done', {\n                passed: false\n            });\n        }\n\n        debug('url %s', url);\n\n        var reporter = new EventEmitter();\n\n        reporter.on('console', function(msg) {\n            console.log.apply(console, msg.args);\n        });\n\n        reporter.on('test', function(test) {\n            console.log('starting', test.name.white);\n        });\n\n        reporter.on('test_end', function(test) {\n            if (!test.passed) {\n                console.log('failed', test.name.red);\n                return self.status.failed++;\n            }\n\n            console.log('passed:', test.name.green);\n            self.status.passed++;\n        });\n\n        reporter.on('assertion', function(assertion) {\n            console.log('Error: %s'.red, assertion.message);\n            assertion.frames.forEach(function(frame) {\n                console.log('    %s %s:%d'.grey, frame.func, frame.filename, frame.line);\n            });\n            console.log();\n        });\n\n        reporter.on('done', function() {\n            reporter.removeAllListeners();\n        });\n\n        self.emit('init', url);\n        self.emit('start', reporter);\n\n        var args = [path.join(__dirname, 'electron-run.js'), url];\n\n        var cp = spawn(binpath, args);\n\n        var errors = [];\n\n        var split = Split();\n        split.on('data', function(line) {\n            var msg;\n            try {\n                msg = JSON.parse(line);\n            } catch (err) {\n                self.emit('error', new Error('failed to parse json: ' + line));\n                return;\n            }\n\n            debug('msg: %j', msg);\n            reporter.emit(msg.type, msg);\n        });\n\n        cp.stdout.setEncoding('utf8');\n        cp.stdout.pipe(split);\n\n        cp.stderr.on('data', function (data) {\n            if (/INFO:CONSOLE/.test(data)) return;\n            debug('electron stderr: '.red + '%s', data);\n        });\n\n        cp.on('close', function (code) {\n            self.emit('done', {\n                passed: self.status.passed,\n                failed: self.status.failed\n            });\n        });\n    });\n};\n\nElectron.prototype.shutdown = function() {\n    if (self.controller) {\n        self.controller.shutdown();\n    }\n};\n\nmodule.exports = Electron;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/hl.js":"var hljs = new function() {\n\n  /* Utility functions */\n\n  function escape(value) {\n    return value.replace(/&/gm, '&amp;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;');\n  }\n\n  function findCode(pre) {\n    for (var node = pre.firstChild; node; node = node.nextSibling) {\n      if (node.nodeName.toUpperCase () == 'CODE')\n        return node;\n      if (!(node.nodeType == 3 && node.nodeValue.match(/\\s+/)))\n        break;\n    }\n  }\n\n  function blockText(block, ignoreNewLines) {\n    return Array.prototype.map.call(block.childNodes, function(node) {\n      if (node.nodeType == 3) {\n        return ignoreNewLines ? node.nodeValue.replace(/\\n/g, '') : node.nodeValue;\n      }\n      if (node.nodeName.toUpperCase () == 'BR') {\n        return '\\n';\n      }\n      return blockText(node, ignoreNewLines);\n    }).join('');\n  }\n\n  function blockLanguage(block) {\n    var classes = (block.className + ' ' + (block.parentNode ? block.parentNode.className : '')).split(/\\s+/);\n    classes = classes.map(function(c) {return c.replace(/^language-/, '');});\n    for (var i = 0; i < classes.length; i++) {\n      if (languages[classes[i]] || classes[i] == 'no-highlight') {\n        return classes[i];\n      }\n    }\n  }\n\n  /* Stream merging */\n\n  function nodeStream(node) {\n    var result = [];\n    (function _nodeStream(node, offset) {\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType == 3)\n          offset += child.nodeValue.length;\n        else if (child.nodeName.toUpperCase() == 'BR')\n          offset += 1;\n        else if (child.nodeType == 1) {\n          result.push({\n            event: 'start',\n            offset: offset,\n            node: child\n          });\n          offset = _nodeStream(child, offset);\n          result.push({\n            event: 'stop',\n            offset: offset,\n            node: child\n          });\n        }\n      }\n      return offset;\n    })(node, 0);\n    return result;\n  }\n\n  function mergeStreams(original, highlighted, value) {\n    var processed = 0;\n    var result = '';\n    var nodeStack = [];\n\n    function selectStream() {\n      if (!original.length || !highlighted.length) {\n        return original.length ? original : highlighted;\n      }\n      if (original[0].offset != highlighted[0].offset) {\n        return (original[0].offset < highlighted[0].offset) ? original : highlighted;\n      }\n\n      /*\n      To avoid starting the stream just before it should stop the order is\n      ensured that original always starts first and closes last:\n\n      if (event1 == 'start' && event2 == 'start')\n        return original;\n      if (event1 == 'start' && event2 == 'stop')\n        return highlighted;\n      if (event1 == 'stop' && event2 == 'start')\n        return original;\n      if (event1 == 'stop' && event2 == 'stop')\n        return highlighted;\n\n      ... which is collapsed to:\n      */\n      return highlighted[0].event == 'start' ? original : highlighted;\n    }\n\n    function open(node) {\n      function attr_str(a) {return ' ' + a.nodeName + '=\"' + escape(a.value) + '\"';}\n      result += '<' + node.nodeName.toLowerCase() + Array.prototype.map.call(node.attributes, attr_str).join('') + '>';\n    }\n\n    function close(node) {\n      result += '</' + node.nodeName.toLowerCase() + '>';\n    }\n\n    function render(event) {\n      (event.event == 'start' ? open : close)(event.node);\n    }\n\n    while (original.length || highlighted.length) {\n      var stream = selectStream();\n      result += escape(value.substr(processed, stream[0].offset - processed));\n      processed = stream[0].offset;\n      if (stream == original) {\n        /*\n        On any opening or closing tag of the original markup we first close\n        the entire highlighted node stack, then render the original tag along\n        with all the following original tags at the same offset and then\n        reopen all the tags on the highlighted stack.\n        */\n        nodeStack.reverse().forEach(close);\n        do {\n          render(stream.splice(0, 1)[0]);\n          stream = selectStream();\n        } while (stream == original && stream.length && stream[0].offset == processed);\n        nodeStack.reverse().forEach(open);\n      } else {\n        if (stream[0].event == 'start') {\n          nodeStack.push(stream[0].node);\n        } else {\n          nodeStack.pop();\n        }\n        render(stream.splice(0, 1)[0]);\n      }\n    }\n    return result + escape(value.substr(processed));\n  }\n\n  /* Initialization */\n\n  function compileLanguage(language) {\n\n    function reStr(re) {\n        return (re && re.source) || re;\n    }\n\n    function langRe(value, global) {\n      return RegExp(\n        reStr(value),\n        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\n      );\n    }\n\n    function compileMode(mode, parent) {\n      if (mode.compiled)\n        return;\n      mode.compiled = true;\n\n      var keywords = []; // used later with beginWithKeyword but filled as a side-effect of keywords compilation\n      if (mode.keywords) {\n        var compiled_keywords = {};\n\n        function flatten(className, str) {\n          if (language.case_insensitive) {\n            str = str.toLowerCase();\n          }\n          str.split(' ').forEach(function(kw) {\n            var pair = kw.split('|');\n            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\n            keywords.push(pair[0]);\n          });\n        }\n\n        mode.lexemsRe = langRe(mode.lexems || '\\\\b' + hljs.IDENT_RE + '\\\\b(?!\\\\.)', true);\n        if (typeof mode.keywords == 'string') { // string\n          flatten('keyword', mode.keywords);\n        } else {\n          for (var className in mode.keywords) {\n            if (!mode.keywords.hasOwnProperty(className))\n              continue;\n            flatten(className, mode.keywords[className]);\n          }\n        }\n        mode.keywords = compiled_keywords;\n      }\n      if (parent) {\n        if (mode.beginWithKeyword) {\n          mode.begin = '\\\\b(' + keywords.join('|') + ')\\\\b(?!\\\\.)\\\\s*';\n        }\n        mode.beginRe = langRe(mode.begin ? mode.begin : '\\\\B|\\\\b');\n        if (!mode.end && !mode.endsWithParent)\n          mode.end = '\\\\B|\\\\b';\n        if (mode.end)\n          mode.endRe = langRe(mode.end);\n        mode.terminator_end = reStr(mode.end) || '';\n        if (mode.endsWithParent && parent.terminator_end)\n          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;\n      }\n      if (mode.illegal)\n        mode.illegalRe = langRe(mode.illegal);\n      if (mode.relevance === undefined)\n        mode.relevance = 1;\n      if (!mode.contains) {\n        mode.contains = [];\n      }\n      for (var i = 0; i < mode.contains.length; i++) {\n        if (mode.contains[i] == 'self') {\n          mode.contains[i] = mode;\n        }\n        compileMode(mode.contains[i], mode);\n      }\n      if (mode.starts) {\n        compileMode(mode.starts, parent);\n      }\n\n      var terminators = [];\n      for (var i = 0; i < mode.contains.length; i++) {\n        terminators.push(reStr(mode.contains[i].begin));\n      }\n      if (mode.terminator_end) {\n        terminators.push(reStr(mode.terminator_end));\n      }\n      if (mode.illegal) {\n        terminators.push(reStr(mode.illegal));\n      }\n      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : {exec: function(s) {return null;}};\n    }\n\n    compileMode(language);\n  }\n\n  /*\n  Core highlighting function. Accepts a language name and a string with the\n  code to highlight. Returns an object with the following properties:\n\n  - relevance (int)\n  - keyword_count (int)\n  - value (an HTML string with highlighting markup)\n\n  */\n  function highlight(language_name, value, ignore_illegals, continuation) {\n\n    function subMode(lexem, mode) {\n      for (var i = 0; i < mode.contains.length; i++) {\n        var match = mode.contains[i].beginRe.exec(lexem);\n        if (match && match.index == 0) {\n          return mode.contains[i];\n        }\n      }\n    }\n\n    function endOfMode(mode, lexem) {\n      if (mode.end && mode.endRe.test(lexem)) {\n        return mode;\n      }\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, lexem);\n      }\n    }\n\n    function isIllegal(lexem, mode) {\n      return !ignore_illegals && mode.illegal && mode.illegalRe.test(lexem);\n    }\n\n    function keywordMatch(mode, match) {\n      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];\n      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];\n    }\n\n    function processKeywords() {\n      var buffer = escape(mode_buffer);\n      if (!top.keywords)\n        return buffer;\n      var result = '';\n      var last_index = 0;\n      top.lexemsRe.lastIndex = 0;\n      var match = top.lexemsRe.exec(buffer);\n      while (match) {\n        result += buffer.substr(last_index, match.index - last_index);\n        var keyword_match = keywordMatch(top, match);\n        if (keyword_match) {\n          keyword_count += keyword_match[1];\n          result += '<span class=\"'+ keyword_match[0] +'\">' + match[0] + '</span>';\n        } else {\n          result += match[0];\n        }\n        last_index = top.lexemsRe.lastIndex;\n        match = top.lexemsRe.exec(buffer);\n      }\n      return result + buffer.substr(last_index);\n    }\n\n    function processSubLanguage() {\n      if (top.subLanguage && !languages[top.subLanguage]) {\n        return escape(mode_buffer);\n      }\n      var continuation = top.subLanguageMode == 'continuous' ? top.top : undefined;\n      var result = top.subLanguage ? highlight(top.subLanguage, mode_buffer, true, continuation) : highlightAuto(mode_buffer);\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Usecase in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance > 0) {\n        keyword_count += result.keyword_count;\n        relevance += result.relevance;\n      }\n      top.top = result.top;\n      return '<span class=\"' + result.language  + '\">' + result.value + '</span>';\n    }\n\n    function processBuffer() {\n      return top.subLanguage !== undefined ? processSubLanguage() : processKeywords();\n    }\n\n    function startNewMode(mode, lexem) {\n      var markup = mode.className? '<span class=\"' + mode.className + '\">': '';\n      if (mode.returnBegin) {\n        result += markup;\n        mode_buffer = '';\n      } else if (mode.excludeBegin) {\n        result += escape(lexem) + markup;\n        mode_buffer = '';\n      } else {\n        result += markup;\n        mode_buffer = lexem;\n      }\n      top = Object.create(mode, {parent: {value: top}});\n    }\n\n    function processLexem(buffer, lexem) {\n      mode_buffer += buffer;\n      if (lexem === undefined) {\n        result += processBuffer();\n        return 0;\n      }\n\n      var new_mode = subMode(lexem, top);\n      if (new_mode) {\n        result += processBuffer();\n        startNewMode(new_mode, lexem);\n        return new_mode.returnBegin ? 0 : lexem.length;\n      }\n\n      var end_mode = endOfMode(top, lexem);\n      if (end_mode) {\n        var origin = top;\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          mode_buffer += lexem;\n        }\n        result += processBuffer();\n        do {\n          if (top.className) {\n            result += '</span>';\n          }\n          relevance += top.relevance;\n          top = top.parent;\n        } while (top != end_mode.parent);\n        if (origin.excludeEnd) {\n          result += escape(lexem);\n        }\n        mode_buffer = '';\n        if (end_mode.starts) {\n          startNewMode(end_mode.starts, '');\n        }\n        return origin.returnEnd ? 0 : lexem.length;\n      }\n\n      if (isIllegal(lexem, top))\n        throw new Error('Illegal lexem \"' + lexem + '\" for mode \"' + (top.className || '<unnamed>') + '\"');\n\n      /*\n      Parser should not reach this point as all types of lexems should be caught\n      earlier, but if it does due to some bug make sure it advances at least one\n      character forward to prevent infinite looping.\n      */\n      mode_buffer += lexem;\n      return lexem.length || 1;\n    }\n\n    var language = languages[language_name];\n    if (!language) {\n      throw new Error('Unknown language: \"' + language_name + '\"');\n    }\n\n    compileLanguage(language);\n    var top = continuation || language;\n    var result = '';\n    for(var current = top; current != language; current = current.parent) {\n      if (current.className) {\n        result = '<span class=\"' + current.className +'\">' + result;\n      }\n    }\n    var mode_buffer = '';\n    var relevance = 0;\n    var keyword_count = 0;\n    try {\n      var match, count, index = 0;\n      while (true) {\n        top.terminators.lastIndex = index;\n        match = top.terminators.exec(value);\n        if (!match)\n          break;\n        count = processLexem(value.substr(index, match.index - index), match[0]);\n        index = match.index + count;\n      }\n      processLexem(value.substr(index));\n      for(var current = top; current.parent; current = current.parent) { // close dangling modes\n        if (current.className) {\n          result += '</span>';\n        }\n      };\n      return {\n        relevance: relevance,\n        keyword_count: keyword_count,\n        value: result,\n        language: language_name,\n        top: top\n      };\n    } catch (e) {\n      if (e.message.indexOf('Illegal') != -1) {\n        return {\n          relevance: 0,\n          keyword_count: 0,\n          value: escape(value)\n        };\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /*\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - keyword_count (int)\n  - value (an HTML string with highlighting markup)\n  - second_best (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n  */\n  function highlightAuto(text) {\n    var result = {\n      keyword_count: 0,\n      relevance: 0,\n      value: escape(text)\n    };\n    var second_best = result;\n    for (var key in languages) {\n      if (!languages.hasOwnProperty(key))\n        continue;\n      var current = highlight(key, text, false);\n      current.language = key;\n      if (current.keyword_count + current.relevance > second_best.keyword_count + second_best.relevance) {\n        second_best = current;\n      }\n      if (current.keyword_count + current.relevance > result.keyword_count + result.relevance) {\n        second_best = result;\n        result = current;\n      }\n    }\n    if (second_best.language) {\n      result.second_best = second_best;\n    }\n    return result;\n  }\n\n  /*\n  Post-processing of the highlighted markup:\n\n  - replace TABs with something more useful\n  - replace real line-breaks with '<br>' for non-pre containers\n\n  */\n  function fixMarkup(value, tabReplace, useBR) {\n    if (tabReplace) {\n      value = value.replace(/^((<[^>]+>|\\t)+)/gm, function(match, p1, offset, s) {\n        return p1.replace(/\\t/g, tabReplace);\n      });\n    }\n    if (useBR) {\n      value = value.replace(/\\n/g, '<br>');\n    }\n    return value;\n  }\n\n  /*\n  Applies highlighting to a DOM node containing code. Accepts a DOM node and\n  two optional parameters for fixMarkup.\n  */\n  function highlightBlock(block, tabReplace, useBR) {\n    var text = blockText(block, useBR);\n    var language = blockLanguage(block);\n    if (language == 'no-highlight')\n        return;\n    var result = language ? highlight(language, text, true) : highlightAuto(text);\n    language = result.language;\n    var original = nodeStream(block);\n    if (original.length) {\n      var pre = document.createElementNS('http://www.w3.org/1999/xhtml', 'pre');\n      pre.innerHTML = result.value;\n      result.value = mergeStreams(original, nodeStream(pre), text);\n    }\n    result.value = fixMarkup(result.value, tabReplace, useBR);\n\n    var class_name = block.className;\n    if (!class_name.match('(\\\\s|^)(language-)?' + language + '(\\\\s|$)')) {\n      class_name = class_name ? (class_name + ' ' + language) : language;\n    }\n    block.innerHTML = result.value;\n    block.className = class_name;\n    block.result = {\n      language: language,\n      kw: result.keyword_count,\n      re: result.relevance\n    };\n    if (result.second_best) {\n      block.second_best = {\n        language: result.second_best.language,\n        kw: result.second_best.keyword_count,\n        re: result.second_best.relevance\n      };\n    }\n  }\n\n  /*\n  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.\n  */\n  function initHighlighting() {\n    if (initHighlighting.called)\n      return;\n    initHighlighting.called = true;\n    Array.prototype.map.call(document.getElementsByTagNameNS('http://www.w3.org/1999/xhtml', 'pre'), findCode).\n      filter(Boolean).\n      forEach(function(code){highlightBlock(code, hljs.tabReplace);});\n  }\n\n  /*\n  Attaches highlighting to the page load event.\n  */\n  function initHighlightingOnLoad() {\n    window.addEventListener('DOMContentLoaded', initHighlighting, false);\n    window.addEventListener('load', initHighlighting, false);\n  }\n\n  var languages = {}; // a shortcut to avoid writing \"this.\" everywhere\n\n  /* Interface definition */\n\n  this.LANGUAGES = languages;\n  this.highlight = highlight;\n  this.highlightAuto = highlightAuto;\n  this.fixMarkup = fixMarkup;\n  this.highlightBlock = highlightBlock;\n  this.initHighlighting = initHighlighting;\n  this.initHighlightingOnLoad = initHighlightingOnLoad;\n\n  // Common regexps\n  this.IDENT_RE = '[a-zA-Z][a-zA-Z0-9_]*';\n  this.UNDERSCORE_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_]*';\n  this.NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\n  this.C_NUMBER_RE = '(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\n  this.BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\n  this.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|\\\\.|-|-=|/|/=|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n  // Common modes\n  this.BACKSLASH_ESCAPE = {\n    begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n  };\n  this.APOS_STRING_MODE = {\n    className: 'string',\n    begin: '\\'', end: '\\'',\n    illegal: '\\\\n',\n    contains: [this.BACKSLASH_ESCAPE],\n    relevance: 0\n  };\n  this.QUOTE_STRING_MODE = {\n    className: 'string',\n    begin: '\"', end: '\"',\n    illegal: '\\\\n',\n    contains: [this.BACKSLASH_ESCAPE],\n    relevance: 0\n  };\n  this.C_LINE_COMMENT_MODE = {\n    className: 'comment',\n    begin: '//', end: '$'\n  };\n  this.C_BLOCK_COMMENT_MODE = {\n    className: 'comment',\n    begin: '/\\\\*', end: '\\\\*/'\n  };\n  this.HASH_COMMENT_MODE = {\n    className: 'comment',\n    begin: '#', end: '$'\n  };\n  this.NUMBER_MODE = {\n    className: 'number',\n    begin: this.NUMBER_RE,\n    relevance: 0\n  };\n  this.C_NUMBER_MODE = {\n    className: 'number',\n    begin: this.C_NUMBER_RE,\n    relevance: 0\n  };\n  this.BINARY_NUMBER_MODE = {\n    className: 'number',\n    begin: this.BINARY_NUMBER_RE,\n    relevance: 0\n  };\n  this.REGEXP_MODE = {\n    className: 'regexp',\n    begin: /\\//, end: /\\/[gim]*/,\n    illegal: /\\n/,\n    contains: [\n      this.BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/, end: /\\]/,\n        relevance: 0,\n        contains: [this.BACKSLASH_ESCAPE]\n      }\n    ]\n  };\n\n  // Utility functions\n  this.inherit = function(parent, obj) {\n    var result = {};\n    for (var key in parent)\n      result[key] = parent[key];\n    if (obj)\n      for (var key in obj)\n        result[key] = obj[key];\n    return result;\n  };\n}();\nhljs.LANGUAGES['javascript'] = require('highlight.js/javascript.js')(hljs);\nmodule.exports = hljs;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/render-stacktrace.js":"'use strict';\n\nvar hljs = require('./hl.js');\n\nfunction getCode(sources, frame) {\n    var codeArr = sources[frame.filename];\n    if (!codeArr || codeArr.length < frame.line) return '';\n\n    var code = codeArr[frame.line - 1];\n\n    // IE<=8 has no trim :(\n    code = (code.trim && code.trim()) || code;\n    if (!code.length) return '';\n\n    // hljs is pretty bad at guessing the language\n    var ext = frame.filename.slice(-3);\n\n    var highlight_fn = hljs.highlightAuto;\n    if (ext === '.js') {\n        highlight_fn = function(src) {\n            return hljs.highlight('javascript', src)\n        }\n    }\n\n    try {\n        return highlight_fn(code).value;\n    } catch (e) {\n        return code;\n    }\n}\n\nfunction hashByFile(source_map) {\n    var sources = source_map.sources;\n    var sources_by_file = {};\n\n    for (var i = 0; i < sources.length; i++) {\n      sources_by_file[sources[i]] = source_map.sourcesContent[i] && source_map.sourcesContent[i].split('\\n')\n    }\n\n    return sources_by_file;\n}\n\nfunction onTraceClick (ev) {\n    if (ev.preventDefault) ev.preventDefault();\n    if (ev.stopPropagation) ev.stopPropagation();\n\n\n    var tgt = ev.target;\n    if (tgt.className !== 'trace') return;\n\n    var input = tgt.parentElement.getElementsByClassName('trace-copy')[0];\n    if (!input) return;\n\n    input.style.display = 'inline';\n    input.style.width = tgt.offsetWidth + 'px';\n    input.focus();\n    input.select();\n\n    input.onblur = function () {\n        input.style.display = 'none';\n        tgt.style.display = 'inline';\n    };\n\n    tgt.style.display = 'none';\n}\n\nvar on_click = 'onclick=\"(' + onTraceClick + ').call(this, arguments[0])\"';\n\nmodule.exports = function (mapped, source_map) {\n    var sources_by_file = hashByFile(source_map);\n\n    var str = '<ul class=\"stack-trace\" style=\"list-style-type: none;\"' + '\" ' + on_click + '>'\n\n    for (var i = 0; i < mapped.length; ++i) {\n        var frame = mapped[i];\n        var code = getCode(sources_by_file, frame);\n\n        // show code for first stacktrace automatically\n        var display = i && code.length ? 'none' : 'block';\n        var anchor_style = code.length ? '' : 'style=\"cursor: default; text-decoration: none;\"';\n\n        str +=  '<li>';\n        str +=      '<span>';\n        str +=          'at ' + frame.func + ' (';\n        str +=          '<input class=\"trace-copy\" spellcheck=\"false\" type=\"text\" value=\"' + frame.filename + ':' + frame.line + '\">';\n        str +=          '<span class=\"trace\">' + frame.filename + ':' + frame.line + '</span>';\n        str +=          ':' + (frame.column || 0) + ')';\n        str +=      '</span>';\n        if (code.length) {\n            str += '<div class=\"hljs\" style=\"display: ' + display + ';\">' + code + '</div>'\n        }\n        str +=   '</li>';\n    }\n\n    str += '</ul>';\n    return str;\n};\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/zuul.js":"'use strict';\n\n// TODO(shtylman)\n// we can do something good with this\n// cause we have the mappings file\n// we can actually show where in the source this is!!\n// before we boot anything we should install this to get reasonable debugging\nwindow.onerror = function(msg, file, line) {\n    //var item = document.createTextNode(msg + ':' + file + ':' + line);\n    //document.body.appendChild(item);\n}\n\nglobal.JSON = global.JSON || require('JSON2');\n\nvar load = require('load-script');\nvar stacktrace = require('stacktrace-js');\nvar ajax = require('superagent');\nvar render_stacktrace = require('./render-stacktrace');\n\ntry {\n    var stack_mapper = require('stack-mapper');\n} catch (err) {}\n\n// post messages here to send back to clients\nvar zuul_msg_bus = window.zuul_msg_bus = [];\n\n// shim console.log so we can report back to user\nif (typeof console === 'undefined') {\n  console = {};\n}\n\nvar originalLog = console.log;\nconsole.log = function (msg) {\n    var args = [].slice.call(arguments);\n\n    zuul_msg_bus.push({\n        type: 'console',\n        args: args\n    });\n\n    if (typeof originalLog === 'function') {\n        return originalLog.apply(this, arguments);\n    }\n    // old ghetto ass IE doesn't report typeof correctly\n    // so we just have to call log\n    else if (originalLog) {\n      return originalLog(arguments[0]);\n    }\n};\n\nvar ZuulReporter = function(run_fn) {\n    if (!(this instanceof ZuulReporter)) {\n        return new ZuulReporter(run_fn);\n    }\n\n    var self = this;\n    self.run_fn = run_fn;\n    self.stats = {\n        passed: 0,\n        pending: 0,\n        failed: 0\n    };\n\n    var main_div = document.getElementById('zuul');\n\n    var header = self.header = document.createElement('div');\n    header.className = 'heading pending';\n    /*global zuul */\n    header.innerHTML = zuul.title;\n    main_div.appendChild(header);\n\n    self.status = header.appendChild(document.createElement('div'));\n    self.status.className = 'status';\n\n    self._set_status(self.stats);\n\n    var sub = document.createElement('div');\n    sub.className = 'sub-heading';\n    sub.innerHTML = navigator.userAgent;\n    main_div.appendChild(sub);\n\n    // Add tab selector\n    var tab_selector = document.createElement('div');\n    tab_selector.id = 'tab-selector';\n    var results_selector = document.createElement('a');\n    results_selector.className = 'selected';\n    results_selector.href = '/__zuul';\n    results_selector.innerHTML = 'Test results';\n    results_selector.onclick = function(e) {\n      var selectors = document.querySelectorAll('#tab-selector a');\n      for (var i = 0; i < selectors.length; i++) {\n        selectors[i].className = ''\n      }\n\n      e.target.className = 'selected';\n\n      document.getElementById('test-results-tab').className = 'tab';\n      document.getElementById('code-coverage-tab').className = 'tab hidden';\n      e.preventDefault();\n    };\n    tab_selector.appendChild(results_selector);\n    var coverage_selector = document.createElement('a');\n    coverage_selector.href = '/__zuul/coverage';\n    coverage_selector.innerHTML = 'Code coverage';\n    coverage_selector.onclick = function(e) {\n      var selectors = document.querySelectorAll('#tab-selector a');\n      for (var i = 0; i < selectors.length; i++) {\n        selectors[i].className = ''\n      }\n\n      e.target.className = 'selected';\n\n      document.getElementById('test-results-tab').className = 'tab hidden';\n      document.getElementById('code-coverage-tab').className = 'tab';\n      e.preventDefault();\n    };\n    tab_selector.appendChild(coverage_selector);\n    main_div.appendChild(tab_selector);\n\n    // Add tabs and their content containers\n    var tabs = document.createElement('div');\n    tabs.className = 'tabs';\n    var test_results_tab = document.createElement('div');\n    test_results_tab.className = 'tab';\n    test_results_tab.id = 'test-results-tab';\n    tabs.appendChild(test_results_tab);\n    var code_coverage_tab = document.createElement('div');\n    code_coverage_tab.className = 'tab hidden';\n    code_coverage_tab.id = 'code-coverage-tab';\n    tabs.appendChild(code_coverage_tab);\n    main_div.appendChild(tabs);\n\n    // status info\n    var status = document.createElement('div');\n\n    document.body.appendChild(main_div);\n    self._current_container = test_results_tab;\n\n    self._mapper = undefined;\n\n    // load test bundle and trigger tests to start\n    // this is a problem for auto starting tests like tape\n    // we need map file first\n    // load map file first then test bundle\n    load('/__zuul/test-bundle.js', load_map);\n\n    function load_map(err) {\n        if (err) {\n            self.done(err);\n        }\n\n        if (!stack_mapper) {\n            return self.start();\n        }\n\n        var map_path = '/__zuul/test-bundle.map.json';\n        ajax.get(map_path).end(function(err, res) {\n            if (err) {\n                // ignore map load error\n                return self.start();\n            }\n\n            self._source_map = res.body;\n            try {\n                self._mapper = stack_mapper(res.body);\n            } catch (err) {}\n\n            self.start();\n        });\n    }\n};\n\nZuulReporter.prototype._set_status = function(info) {\n    var self = this;\n    var html = '';\n    html += '<span>' + info.failed + ' <small>failing</small></span> ';\n    html += '<span>' + info.passed + ' <small>passing</small></span> ';\n    if(self.stats.pending){\n        html += '<span>' + info.pending + ' <small>pending</small></span>';\n    }\n\n    self.status.innerHTML = html;\n};\n\n// tests are starting\nZuulReporter.prototype.start = function() {\n    var self = this;\n    self.run_fn();\n};\n\n// all tests done\nZuulReporter.prototype.done = function(err) {\n    var self = this;\n\n    var stats = self.stats;\n    var passed = stats.failed === 0 && stats.passed > 0;\n\n    if (passed) {\n        self.header.className += ' passed';\n    }\n    else {\n        self.header.className += ' failed';\n    }\n\n    // add coverage tab content\n    if (window.__coverage__) {\n        var coverage_tab = document.getElementById('code-coverage-tab');\n        coverage_tab.innerHTML = '<iframe frameborder=\"0\" src=\"/__zuul/coverage\"></iframe>';\n    }\n\n    post_message({\n        type: 'done',\n        stats: stats,\n        passed: passed\n    });\n};\n\n// new test starting\nZuulReporter.prototype.test = function(test) {\n    var self = this;\n\n    var container = document.createElement('div');\n    container.className = 'test pending';\n\n    var header = container.appendChild(document.createElement('h1'));\n    header.innerHTML = test.name;\n\n    self._current_container = self._current_container.appendChild(container);\n\n    post_message({\n        type: 'test',\n        name: test.name\n    });\n};\n\n// reports on skipped tests\nZuulReporter.prototype.skippedTest = function(test){\n    var self = this;\n\n    self.stats.pending++;\n\n    var container = document.createElement('div');\n    container.className = 'test pending skipped';\n\n    var header = container.appendChild(document.createElement('h1'));\n    header.innerHTML = test.name;\n\n    self._current_container.appendChild(container);\n\n    self._set_status(self.stats);\n\n    post_message({\n        type: 'test',\n        name: test.name\n    });\n};\n\n// test ended\nZuulReporter.prototype.test_end = function(test) {\n    var self = this;\n    var name = test.name;\n\n    var cls = test.passed ? 'passed' : 'failed';\n\n    if (test.passed) {\n        self.stats.passed++;\n    }\n    else {\n        self.stats.failed++;\n    }\n\n    // current test element\n    self._current_container.className += ' ' + cls;\n    // use parentNode for legacy browsers (firefox)\n    self._current_container = self._current_container.parentNode;\n\n    self._set_status(self.stats);\n\n    var cov = window.__coverage__ ;\n\n    if (cov) {\n        ajax.post('/__zuul/coverage/client')\n        .send(cov)\n        .end(function(err, res) {\n            if (err) {\n                console.log('error in coverage reports');\n                console.log(err);\n            }\n        });\n    }\n\n    post_message({\n        type: 'test_end',\n        name: test.name,\n        passed: test.passed\n    });\n};\n\n// new suite starting\nZuulReporter.prototype.suite = function(suite) {\n    var self = this;\n};\n\n// suite ended\nZuulReporter.prototype.suite_end = function(suite) {\n    var self = this;\n};\n\n// assertion within test\nZuulReporter.prototype.assertion = function(details) {\n    var self = this;\n    // result (true | false)\n    // actual\n    // expected\n    // message\n    // error\n    // source (stack) if available\n\n    var passed = details.result;\n\n    if (passed) {\n        return;\n    }\n\n    if (details.message) {\n        var pre = document.createElement('pre');\n        pre.innerHTML = details.message;\n        self._current_container.appendChild(pre);\n    }\n\n    // TODO actual, expected\n\n    var message = details.message;\n    var error = details.error;\n    var stack = details.source;\n\n    if (!stack && error) {\n        // rethrow to try and get the stack\n        // IE needs this (of course)\n        try {\n            throw error;\n        } catch (ex) {\n            error = ex;\n            stack = error.stack;\n        }\n    }\n\n    var frames = [];\n    try {\n        frames = stacktrace(error);\n    } catch (err) {}\n\n    self._renderError(stack, frames, message, error);\n\n    post_message({\n        type: 'assertion',\n        actual: details.actual,\n        expected: details.expected,\n        message: details.message,\n        source: details.source,\n        frames: frames\n    });\n};\n\nZuulReporter.prototype._renderError = function (stack, frames, message, error) {\n    var self = this;\n    var mapper = self._mapper;\n    var str;\n\n    if (mapper && frames.length) {\n        var mapped = mapper.map(frames);\n        str = render_stacktrace(mapped, self._source_map);\n    }\n\n    var div = document.createElement('div');\n    div.innerHTML = str ? str : (stack || message || error.toString());\n    self._current_container.appendChild(div);\n};\n\nfunction plainString (mapped) {\n    var str = '';\n    for (var i = 0; i <mapped.length; ++i) {\n        var frame = mapped[i];\n        str += '\\n\\tat ';\n        str += frame.func + ' (' + frame.filename + ':' + frame.line + ':';\n        str += (frame.column || 0) + ')';\n    }\n}\n\nfunction post_message(msg) {\n    zuul_msg_bus.push(msg);\n}\n\nmodule.exports = ZuulReporter;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/builder-browserify.js":"'use strict';\n\nvar _ = require('lodash');\nvar watchify = require('watchify');\nvar browserify = require('browserify');\nvar istanbul = require('browserify-istanbul');\nvar convert = require('convert-source-map');\nvar debug = require('debug')('zuul:browserify');\nvar humanizeDuration = require('humanize-duration');\n\nfunction configure(bundler, cfg) {\n    if (!cfg) {\n        return;\n    }\n\n    var registerableCfg = [\n        'plugin',\n        'external',\n        'ignore',\n        'exclude',\n        'transform',\n        'add',\n        'require'\n    ];\n\n    cfg.forEach(registerable);\n\n    // grab registerable configs and register them\n    function registerable (cfgObj) {\n        _.forIn(cfgObj, function(value, key) {\n            if (registerableCfg.indexOf(key) !== -1) {\n                register(key, cfgObj);\n            }\n        });\n    }\n\n    function register (type, o) {\n        debug('registering %s: %s', type, o[type]);\n        if (type === 'transform' && typeof o[type] === 'object') {\n            bundler[type](o[type].name, _.omit(o[type], 'name'));\n        } else {\n            bundler[type](o[type], _.omit(o, type));\n        }\n    }\n}\n\n// the builder API is var build = require('builder')(files, config); build(cb)\n// So that we can have multiple different `watchifyBundler` caches per build instance.\nmodule.exports = function(files, config) {\n    var watchifyBundler = initBundler(files, config);\n\n    return function(cb) {\n        var start = Date.now();\n        watchifyBundler.bundle(function(err, buf) {\n            if (err) {\n                return cb(err);\n            }\n\n            var src = buf.toString();\n            var srcmap = convert.fromSource(src);\n            var map = undefined;\n            src = convert.removeComments(src);\n\n            if (srcmap) {\n                map = srcmap.toObject();\n            }\n\n            debug('test files took %s to bundle', humanizeDuration(Date.now() - start));\n            cb(null, src, map);\n        });\n    };\n};\n\nfunction initBundler(files, config) {\n    var opt = {\n        debug: true,\n        basedir: config.prj_dir\n    };\n\n    // watchify options\n    // https://github.com/substack/watchify#var-w--watchifyb-opts\n    opt = _.assign(opt, {\n        cache: {},\n        packageCache: {},\n        fullPaths: true\n    });\n\n    var userConfig = _.find(config.browserify, 'options');\n    var browserifyOptions = _.assign({}, opt);\n\n    if (userConfig) {\n        browserifyOptions = _.assign(browserifyOptions, userConfig.options || {});\n    }\n\n    var bundler = browserify(browserifyOptions);\n\n    debug('configuring browserify with provided options: %j', config.browserify);\n    configure(bundler, config.browserify);\n\n    if (config.coverage && config.local) {\n        debug('using istanbul transform');\n        bundler.transform(istanbul({\n            defaultIgnore: true\n        }));\n    }\n\n    debug('adding to bundle: %j', files);\n    files.forEach(function(file) {\n        bundler.require(file, { entry: true });\n    });\n\n    bundler = watchify(bundler);\n\n    return bundler;\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/electron-inject.js":"!function() {\n    var ipc;\n    try {\n      ipc = require('electron').ipcRenderer;\n    } catch (e) {\n      ipc = require('ipc');\n    }\n    window.zuul_msg_bus = [];\n    ipc.on('started', loop);\n    window.setTimeout(ipc.send.bind(ipc, 'started'));\n    function loop() {\n        var msgs = window.zuul_msg_bus.splice(0, window.zuul_msg_bus.length);\n        msgs.forEach(send);\n        setTimeout(loop, 100);\n    }\n    function send(msg) {\n        ipc.send('zuulmessage', msg);\n    }\n}();\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/electron-run.js":"var electron;\n\ntry {\n  electron = require('electron');\n} catch (e) {\n  electron = {\n      app: require('app'),\n      ipcMain: require('ipc'),\n      BrowserWindow: require('browser-window')\n  };\n}\n\nvar url = process.argv[2];\n\nelectron.app.on('ready', function () {\n    var options = {\n      show: false,\n      webPreferences: {\n        preload: __dirname + '/electron-inject.js'\n      }\n    };\n    options.preload = options.webPreferences.preload;\n    var mainWindow = new electron.BrowserWindow(options);\n\n    (mainWindow.loadURL || mainWindow.loadUrl).call(mainWindow, url);\n\n    electron.ipcMain.once('started', function () {\n        mainWindow.send('started');\n    });\n\n    electron.ipcMain.on('zuulmessage', function(e, msg) {\n        console.log(JSON.stringify(msg));\n        if (msg.type === 'done') {\n          electron.app.quit();\n        }\n    });\n});\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/flatten_browser.js":"var xtend = require('xtend');\nvar uniq = require('lodash').uniq;\n\n// given a list of browsers we want to test\n// expand into an actual testable list of browsers\n// @param {Array} request array of { name: 'chrome', version: <version str>, platform: <os> }\n// @param {Object} supported browsers and versions\n// @return {Array} browsers to test { name: <browser name>, version: <version>, platform: <os> }\nfunction flatten(request, all_browsers) {\n    var browsers = [];\n\n    // turn each browser request into an array of valid browsers\n    request.forEach(function(req) {\n        if (!all_browsers[req.name]) {\n            return;\n        }\n        // clone because we will modify to filter down\n        var avail = all_browsers[req.name].slice(0);\n\n        if (req.platform && typeof req.platform === 'string') {\n            avail = avail.filter(function(browser) {\n                return req.platform.toLowerCase() === browser.platform.toLowerCase();\n            });\n        }\n        else if (req.platform && Array.isArray(req.platform)) {\n            req.platform = req.platform.map(function(platform) {\n                return platform.toLowerCase();\n            });\n\n            avail = avail.filter(function(browser) {\n                return req.platform.indexOf(browser.platform.toLowerCase()) > -1;\n            });\n        }\n\n        if (avail.length === 0) {\n            return;\n        }\n\n        // sort version entries putting 'beta' last\n        avail = avail.sort(function(a, b) {\n            if (a.version === b.version) {\n                return 0;\n            }\n            else if (Number.isNaN(Number(a.version))) {\n                return 1;\n            }\n            else if (Number.isNaN(Number(b.version))) {\n                return -1;\n            }\n            return a.version - b.version;\n        });\n\n        // remove duplicate version entries\n        // because we are not interested in testing on all platforms\n        // unless explicitly asked\n        if (!req.platform) {\n            avail.reduce(function(prev, curr, idx, arr) {\n                if (prev && prev.version === curr.version) {\n                    arr[idx] = undefined;\n                }\n                return curr;\n            });\n        }\n\n        avail = avail.filter(Boolean);\n\n        // version is an array, we should add each item from array\n        if (Array.isArray(req.version)) {\n            return req.version.forEach(function(version) {\n                browsers.push.apply(browsers, process_version_str(version));\n                return;\n            });\n        }\n\n        browsers.push.apply(browsers, process_version_str(req.version));\n        return;\n\n        // return an array of browsers to match version string\n        // version string can be a single version\n        // or a range ##..##\n        // or ##..latest\n        function process_version_str(version) {\n            version = String(version);\n            if (version === 'latest') {\n                if (Array.isArray(req.platform)) {\n                    var latest = get_numeric_versions(avail).slice(-1)[0].version;\n                    return avail.filter(function(browser) {\n                        return browser.version === latest;\n                    });\n                }\n                else {\n                    return get_numeric_versions(avail).slice(-1).map(addProfile);\n                }\n            }\n            else if (version === 'oldest') {\n                if (Array.isArray(req.platform)) {\n                    var oldest = get_numeric_versions(avail).slice(0, 1)[0].version;\n                    return avail.filter(function(browser) {\n                        return browser.version === oldest;\n                    });\n                }\n                else {\n                    return avail.slice(0, 1).map(addProfile);\n                }\n            }\n\n            // split version string on two dots to see if range was specified\n            var split = version.split('..');\n\n            // range specified via ##..##\n            if (split.length === 2) {\n                var start = split[0];\n                var end = split[1];\n\n                var start_idx = 0;\n                var end_idx = avail.length - 1;\n\n                var v_map = avail.map(function(item) {\n                    return item.version;\n                });\n\n                if (end === 'latest') {\n                    end_idx = get_numeric_versions(avail).length - 1;\n                }\n                else {\n                    end_idx = v_map.lastIndexOf(end);\n                }\n\n                if (start < 0) {\n                    start_idx = end_idx + Number(start);\n                }\n                else if (start !== 'oldest') {\n                    start_idx = v_map.indexOf(start);\n                }\n\n                if (start_idx < 0) {\n                    throw new Error('unable to find start version: ' + start);\n                }\n                else if (end_idx < 0) {\n                    throw new Error('unable to find end version: ' + end);\n                }\n\n                return avail.slice(start_idx, end_idx + 1).map(addProfile);\n            }\n\n            return avail.filter(function(browser) {\n                // JS will forget about the .0 when reading any float that can\n                // be represented as an integer from yaml, so let's try to\n                // match a version of that form as a fallback\n                return browser.version == version || browser.version == version + '.0';\n            }).map(addProfile);\n\n            function get_numeric_versions(browsers) {\n                return browsers.filter(function (el) {\n                    return Number(el.version) >= 0;\n                })\n            }\n\n            function addProfile(browser) {\n                if (req.firefox_profile) {\n                    return xtend(browser, {\n                        firefox_profile: req.firefox_profile\n                    });\n                }\n\n                return browser;\n            }\n        }\n    });\n\n    return uniq(browsers);\n}\n\nmodule.exports = flatten;\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/phantom-run.js":"// THIS IS A PHANTOMJS SCRIPT FILE //\n// see PhantomBrowser.js for use //\n\nvar page = require('webpage').create();\nvar system = require('system');\n\nvar url = system.args[1];\nvar systemMessages = [];\n\nphantom.onError = function(msg, trace) {\n    systemMessages.push({\n        type: 'exception',\n        message: msg,\n        trace: trace\n    });\n};\n\npage.onError = function(msg, trace) {\n    systemMessages.push({\n        type: 'exception',\n        message: msg,\n        trace: trace\n    });\n};\n\npage.open(url, function(status) {\n    var msg_tid = setInterval(function() {\n        var msgs = page.evaluate(function() {\n            return window.zuul_msg_bus && window.zuul_msg_bus.splice(0, window.zuul_msg_bus.length);\n        }) || [];\n\n        var messages = msgs.concat(systemMessages.splice(0, systemMessages.length));\n\n        messages.forEach(function(msg) {\n            console.log(JSON.stringify(msg));\n            if (msg.type === 'exception') {\n                console.error(msg.message);\n                console.trace(msg.trace);\n                return setTimeout(function() {\n                    phantom.exit(1);\n                });\n            }\n            if (msg.type === 'done') {\n                return setTimeout(function() {\n                  phantom.exit(msg.passed ? 0 : 1);\n                });\n            }\n        });\n    }, 100);\n});\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/lib/scout_browser.js":"// returns available browsers to test on\n// results are keyed by browser\n// each browser has an array of objects with version and platform info\n// some versions may have more than one OS they can run on\n// {\n//     'chrome': [\n//        { version: 27, platform: 'Windows XP' }\n//        { version: 27, platform: 'Mac 10.6' }\n//     ]\n// }\n\nvar https = require('https');\n\nmodule.exports = function(cb) {\n    var info_opt = {\n        host: 'saucelabs.com',\n        path: '/rest/v1/info/browsers/webdriver'\n    };\n\n    https.get(info_opt, function(res) {\n        res.setEncoding('utf8');\n        var body = '';\n\n        res.on('data', function(data) {\n            body += data;\n        });\n\n        res.once('end', function() {\n            try {\n                var formatted = format(JSON.parse(body));\n            } catch (err) {\n                return cb(err);\n            }\n\n            cb(null, formatted);\n        });\n\n        res.once('error', cb);\n    });\n};\n\nfunction format(obj) {\n    var browsers = {};\n    obj.forEach(function(info) {\n        var name = info.api_name;\n\n        var browser = browsers[name] = browsers[name] || [];\n        browser.push({\n            name: name,\n            version: info.short_version,\n            platform: info.os,\n        });\n    });\n\n    return browsers;\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/jasmine2/client.js":"var ZuulReporter = require('../zuul');\nvar reporter = ZuulReporter(run);\n\nfunction ZuulJasmineReporter() {}\n\nZuulJasmineReporter.prototype.reportFirstSpecFailure = function(results) {\n    if (!results.length) {\n        return;\n    }\n\n    var result = results[0];\n    reporter.assertion({\n        result: false,\n        actual: result.actual,\n        expected: result.expected,\n        message: result.message,\n        source: result.stack\n    });\n};\n\nZuulJasmineReporter.prototype.getFullSpecName = function(spec, separator) {\n    separator = separator || \" :: \";\n\n    function getFullSuiteName(suite) {\n        var parentSuitesNames = suite.parentSuite ? getFullSuiteName(suite.parentSuite) + separator : \"\";\n        return parentSuitesNames + suite.description;\n    }\n\n    return getFullSuiteName(this.suite) + separator + spec.description;\n};\n\nZuulJasmineReporter.prototype.jasmineDone = function () {\n    reporter.done();\n};\n\nZuulJasmineReporter.prototype.suiteStarted = function(suite) {\n    this.suite = suite;\n};\n\nZuulJasmineReporter.prototype.specStarted = function (spec) {\n    reporter.test({\n        name: this.getFullSpecName(spec)\n    });\n};\n\nZuulJasmineReporter.prototype.specDone = function (spec) {\n    var passed = !spec.failedExpectations.length;\n\n    if (!passed) {\n        this.reportFirstSpecFailure(spec.failedExpectations);\n    }\n\n    reporter.test_end({\n        name: this.getFullSpecName(spec),\n        passed: passed\n    });\n};\n\nvar zuulJasmineReporter = new ZuulJasmineReporter();\n\n// Set up jasmine\nvar jasmineRequire = getJasmineRequireObj();\nvar jasmineCore = jasmineRequire.core(jasmineRequire);\nwindow.jasmine = jasmineCore;\nvar jasmineEnv = jasmineCore.getEnv();\nvar jasmineInterface = jasmineRequire.interface(jasmineCore, jasmineEnv);\nfor (var key in jasmineInterface) {\n    window[key] = jasmineInterface[key];\n}\n\njasmineEnv.addReporter(zuulJasmineReporter);\n\nfunction run() {\n    jasmineEnv.execute();\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/jasmine2/framework.js":"/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar getJasmineRequireObj = (function (jasmineGlobal) {\n  var jasmineRequire;\n\n  if (typeof module !== 'undefined' && module.exports) {\n    jasmineGlobal = global;\n    jasmineRequire = exports;\n  } else {\n    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {\n      jasmineGlobal = window;\n    }\n    jasmineRequire = jasmineGlobal.jasmineRequire = jasmineGlobal.jasmineRequire || {};\n  }\n\n  function getJasmineRequire() {\n    return jasmineRequire;\n  }\n\n  getJasmineRequire().core = function(jRequire) {\n    var j$ = {};\n\n    jRequire.base(j$, jasmineGlobal);\n    j$.util = jRequire.util();\n    j$.Any = jRequire.Any();\n    j$.Anything = jRequire.Anything(j$);\n    j$.CallTracker = jRequire.CallTracker();\n    j$.MockDate = jRequire.MockDate();\n    j$.Clock = jRequire.Clock();\n    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\n    j$.Env = jRequire.Env(j$);\n    j$.ExceptionFormatter = jRequire.ExceptionFormatter();\n    j$.Expectation = jRequire.Expectation();\n    j$.buildExpectationResult = jRequire.buildExpectationResult();\n    j$.JsApiReporter = jRequire.JsApiReporter();\n    j$.matchersUtil = jRequire.matchersUtil(j$);\n    j$.ObjectContaining = jRequire.ObjectContaining(j$);\n    j$.ArrayContaining = jRequire.ArrayContaining(j$);\n    j$.pp = jRequire.pp(j$);\n    j$.QueueRunner = jRequire.QueueRunner(j$);\n    j$.ReportDispatcher = jRequire.ReportDispatcher();\n    j$.Spec = jRequire.Spec(j$);\n    j$.SpyRegistry = jRequire.SpyRegistry(j$);\n    j$.SpyStrategy = jRequire.SpyStrategy();\n    j$.StringMatching = jRequire.StringMatching(j$);\n    j$.Suite = jRequire.Suite();\n    j$.Timer = jRequire.Timer();\n    j$.version = jRequire.version();\n\n    j$.matchers = jRequire.requireMatchers(jRequire, j$);\n\n    return j$;\n  };\n\n  return getJasmineRequire;\n})(this);\n\ngetJasmineRequireObj().requireMatchers = function(jRequire, j$) {\n  var availableMatchers = [\n      'toBe',\n      'toBeCloseTo',\n      'toBeDefined',\n      'toBeFalsy',\n      'toBeGreaterThan',\n      'toBeLessThan',\n      'toBeNaN',\n      'toBeNull',\n      'toBeTruthy',\n      'toBeUndefined',\n      'toContain',\n      'toEqual',\n      'toHaveBeenCalled',\n      'toHaveBeenCalledWith',\n      'toMatch',\n      'toThrow',\n      'toThrowError'\n    ],\n    matchers = {};\n\n  for (var i = 0; i < availableMatchers.length; i++) {\n    var name = availableMatchers[i];\n    matchers[name] = jRequire[name](j$);\n  }\n\n  return matchers;\n};\n\ngetJasmineRequireObj().base = function(j$, jasmineGlobal) {\n  j$.unimplementedMethod_ = function() {\n    throw new Error('unimplemented method');\n  };\n\n  j$.MAX_PRETTY_PRINT_DEPTH = 40;\n  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;\n  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\n\n  j$.getGlobal = function() {\n    return jasmineGlobal;\n  };\n\n  j$.getEnv = function(options) {\n    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\n    //jasmine. singletons in here (setTimeout blah blah).\n    return env;\n  };\n\n  j$.isArray_ = function(value) {\n    return j$.isA_('Array', value);\n  };\n\n  j$.isString_ = function(value) {\n    return j$.isA_('String', value);\n  };\n\n  j$.isNumber_ = function(value) {\n    return j$.isA_('Number', value);\n  };\n\n  j$.isA_ = function(typeName, value) {\n    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n  };\n\n  j$.isDomNode = function(obj) {\n    return obj.nodeType > 0;\n  };\n\n  j$.fnNameFor = function(func) {\n    return func.name || func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/)[1];\n  };\n\n  j$.any = function(clazz) {\n    return new j$.Any(clazz);\n  };\n\n  j$.anything = function() {\n    return new j$.Anything();\n  };\n\n  j$.objectContaining = function(sample) {\n    return new j$.ObjectContaining(sample);\n  };\n\n  j$.stringMatching = function(expected) {\n    return new j$.StringMatching(expected);\n  };\n\n  j$.arrayContaining = function(sample) {\n    return new j$.ArrayContaining(sample);\n  };\n\n  j$.createSpy = function(name, originalFn) {\n\n    var spyStrategy = new j$.SpyStrategy({\n        name: name,\n        fn: originalFn,\n        getSpy: function() { return spy; }\n      }),\n      callTracker = new j$.CallTracker(),\n      spy = function() {\n        var callData = {\n          object: this,\n          args: Array.prototype.slice.apply(arguments)\n        };\n\n        callTracker.track(callData);\n        var returnValue = spyStrategy.exec.apply(this, arguments);\n        callData.returnValue = returnValue;\n\n        return returnValue;\n      };\n\n    for (var prop in originalFn) {\n      if (prop === 'and' || prop === 'calls') {\n        throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\n      }\n\n      spy[prop] = originalFn[prop];\n    }\n\n    spy.and = spyStrategy;\n    spy.calls = callTracker;\n\n    return spy;\n  };\n\n  j$.isSpy = function(putativeSpy) {\n    if (!putativeSpy) {\n      return false;\n    }\n    return putativeSpy.and instanceof j$.SpyStrategy &&\n      putativeSpy.calls instanceof j$.CallTracker;\n  };\n\n  j$.createSpyObj = function(baseName, methodNames) {\n    if (j$.isArray_(baseName) && j$.util.isUndefined(methodNames)) {\n      methodNames = baseName;\n      baseName = 'unknown';\n    }\n\n    if (!j$.isArray_(methodNames) || methodNames.length === 0) {\n      throw 'createSpyObj requires a non-empty array of method names to create spies for';\n    }\n    var obj = {};\n    for (var i = 0; i < methodNames.length; i++) {\n      obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);\n    }\n    return obj;\n  };\n};\n\ngetJasmineRequireObj().util = function() {\n\n  var util = {};\n\n  util.inherit = function(childClass, parentClass) {\n    var Subclass = function() {\n    };\n    Subclass.prototype = parentClass.prototype;\n    childClass.prototype = new Subclass();\n  };\n\n  util.htmlEscape = function(str) {\n    if (!str) {\n      return str;\n    }\n    return str.replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  };\n\n  util.argsToArray = function(args) {\n    var arrayOfArgs = [];\n    for (var i = 0; i < args.length; i++) {\n      arrayOfArgs.push(args[i]);\n    }\n    return arrayOfArgs;\n  };\n\n  util.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  util.arrayContains = function(array, search) {\n    var i = array.length;\n    while (i--) {\n      if (array[i] === search) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  util.clone = function(obj) {\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\n      return obj.slice();\n    }\n\n    var cloned = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        cloned[prop] = obj[prop];\n      }\n    }\n\n    return cloned;\n  };\n\n  return util;\n};\n\ngetJasmineRequireObj().Spec = function(j$) {\n  function Spec(attrs) {\n    this.expectationFactory = attrs.expectationFactory;\n    this.resultCallback = attrs.resultCallback || function() {};\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\n    this.userContext = attrs.userContext || function() { return {}; };\n    this.onStart = attrs.onStart || function() {};\n    this.getSpecName = attrs.getSpecName || function() { return ''; };\n    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\n    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\n\n    if (!this.queueableFn.fn) {\n      this.pend();\n    }\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: ''\n    };\n  }\n\n  Spec.prototype.addExpectationResult = function(passed, data) {\n    var expectationResult = this.expectationResultFactory(data);\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n    }\n  };\n\n  Spec.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Spec.prototype.execute = function(onComplete) {\n    var self = this;\n\n    this.onStart(this);\n\n    if (this.markedPending || this.disabled) {\n      complete();\n      return;\n    }\n\n    var fns = this.beforeAndAfterFns();\n    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n\n    this.queueRunnerFactory({\n      queueableFns: allFns,\n      onException: function() { self.onException.apply(self, arguments); },\n      onComplete: complete,\n      userContext: this.userContext()\n    });\n\n    function complete() {\n      self.result.status = self.status();\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  };\n\n  Spec.prototype.onException = function onException(e) {\n    if (Spec.isPendingSpecException(e)) {\n      this.pend(extractCustomPendingMessage(e));\n      return;\n    }\n\n    this.addExpectationResult(false, {\n      matcherName: '',\n      passed: false,\n      expected: '',\n      actual: '',\n      error: e\n    });\n  };\n\n  Spec.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Spec.prototype.pend = function(message) {\n    this.markedPending = true;\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  };\n\n  Spec.prototype.status = function() {\n    if (this.disabled) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  };\n\n  Spec.prototype.isExecutable = function() {\n    return !this.disabled && !this.markedPending;\n  };\n\n  Spec.prototype.getFullName = function() {\n    return this.getSpecName(this);\n  };\n\n  var extractCustomPendingMessage = function(e) {\n    var fullMessage = e.toString(),\n        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\n        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n\n    return fullMessage.substr(boilerplateEnd);\n  };\n\n  Spec.pendingSpecExceptionMessage = '=> marked Pending';\n\n  Spec.isPendingSpecException = function(e) {\n    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\n  };\n\n  return Spec;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Spec = jasmineRequire.Spec;\n}\n\ngetJasmineRequireObj().Env = function(j$) {\n  function Env(options) {\n    options = options || {};\n\n    var self = this;\n    var global = options.global || j$.getGlobal();\n\n    var totalSpecsDefined = 0;\n\n    var catchExceptions = true;\n\n    var realSetTimeout = j$.getGlobal().setTimeout;\n    var realClearTimeout = j$.getGlobal().clearTimeout;\n    this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\n\n    var runnableLookupTable = {};\n    var runnableResources = {};\n\n    var currentSpec = null;\n    var currentlyExecutingSuites = [];\n    var currentDeclarationSuite = null;\n\n    var currentSuite = function() {\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n    };\n\n    var currentRunnable = function() {\n      return currentSpec || currentSuite();\n    };\n\n    var reporter = new j$.ReportDispatcher([\n      'jasmineStarted',\n      'jasmineDone',\n      'suiteStarted',\n      'suiteDone',\n      'specStarted',\n      'specDone'\n    ]);\n\n    this.specFilter = function() {\n      return true;\n    };\n\n    this.addCustomEqualityTester = function(tester) {\n      if(!currentRunnable()) {\n        throw new Error('Custom Equalities must be added in a before function or a spec');\n      }\n      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\n    };\n\n    this.addMatchers = function(matchersToAdd) {\n      if(!currentRunnable()) {\n        throw new Error('Matchers must be added in a before function or a spec');\n      }\n      var customMatchers = runnableResources[currentRunnable().id].customMatchers;\n      for (var matcherName in matchersToAdd) {\n        customMatchers[matcherName] = matchersToAdd[matcherName];\n      }\n    };\n\n    j$.Expectation.addCoreMatchers(j$.matchers);\n\n    var nextSpecId = 0;\n    var getNextSpecId = function() {\n      return 'spec' + nextSpecId++;\n    };\n\n    var nextSuiteId = 0;\n    var getNextSuiteId = function() {\n      return 'suite' + nextSuiteId++;\n    };\n\n    var expectationFactory = function(actual, spec) {\n      return j$.Expectation.Factory({\n        util: j$.matchersUtil,\n        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\n        customMatchers: runnableResources[spec.id].customMatchers,\n        actual: actual,\n        addExpectationResult: addExpectationResult\n      });\n\n      function addExpectationResult(passed, result) {\n        return spec.addExpectationResult(passed, result);\n      }\n    };\n\n    var defaultResourcesForRunnable = function(id, parentRunnableId) {\n      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\n\n      if(runnableResources[parentRunnableId]){\n        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\n        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\n      }\n\n      runnableResources[id] = resources;\n    };\n\n    var clearResourcesForRunnable = function(id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n    };\n\n    var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\n      return function() {\n        var befores = [],\n          afters = [],\n          beforeAlls = [],\n          afterAlls = [];\n\n        while(suite) {\n          befores = befores.concat(suite.beforeFns);\n          afters = afters.concat(suite.afterFns);\n\n          if (runnablesExplictlySet()) {\n            beforeAlls = beforeAlls.concat(suite.beforeAllFns);\n            afterAlls = afterAlls.concat(suite.afterAllFns);\n          }\n\n          suite = suite.parentSuite;\n        }\n        return {\n          befores: beforeAlls.reverse().concat(befores.reverse()),\n          afters: afters.concat(afterAlls)\n        };\n      };\n    };\n\n    var getSpecName = function(spec, suite) {\n      return suite.getFullName() + ' ' + spec.description;\n    };\n\n    // TODO: we may just be able to pass in the fn instead of wrapping here\n    var buildExpectationResult = j$.buildExpectationResult,\n        exceptionFormatter = new j$.ExceptionFormatter(),\n        expectationResultFactory = function(attrs) {\n          attrs.messageFormatter = exceptionFormatter.message;\n          attrs.stackFormatter = exceptionFormatter.stack;\n\n          return buildExpectationResult(attrs);\n        };\n\n    // TODO: fix this naming, and here's where the value comes in\n    this.catchExceptions = function(value) {\n      catchExceptions = !!value;\n      return catchExceptions;\n    };\n\n    this.catchingExceptions = function() {\n      return catchExceptions;\n    };\n\n    var maximumSpecCallbackDepth = 20;\n    var currentSpecCallbackDepth = 0;\n\n    function clearStack(fn) {\n      currentSpecCallbackDepth++;\n      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\n        currentSpecCallbackDepth = 0;\n        realSetTimeout(fn, 0);\n      } else {\n        fn();\n      }\n    }\n\n    var catchException = function(e) {\n      return j$.Spec.isPendingSpecException(e) || catchExceptions;\n    };\n\n    var queueRunnerFactory = function(options) {\n      options.catchException = catchException;\n      options.clearStack = options.clearStack || clearStack;\n      options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\n      options.fail = self.fail;\n\n      new j$.QueueRunner(options).execute();\n    };\n\n    var topSuite = new j$.Suite({\n      env: this,\n      id: getNextSuiteId(),\n      description: 'Jasmine__TopLevel__Suite',\n      queueRunner: queueRunnerFactory\n    });\n    runnableLookupTable[topSuite.id] = topSuite;\n    defaultResourcesForRunnable(topSuite.id);\n    currentDeclarationSuite = topSuite;\n\n    this.topSuite = function() {\n      return topSuite;\n    };\n\n    this.execute = function(runnablesToRun) {\n      if(runnablesToRun) {\n        runnablesExplictlySet = true;\n      } else if (focusedRunnables.length) {\n        runnablesExplictlySet = true;\n        runnablesToRun = focusedRunnables;\n      } else {\n        runnablesToRun = [topSuite.id];\n      }\n\n      var allFns = [];\n      for(var i = 0; i < runnablesToRun.length; i++) {\n        var runnable = runnableLookupTable[runnablesToRun[i]];\n        allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\n      }\n\n      reporter.jasmineStarted({\n        totalSpecsDefined: totalSpecsDefined\n      });\n\n      queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\n    };\n\n    this.addReporter = function(reporterToAdd) {\n      reporter.addReporter(reporterToAdd);\n    };\n\n    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\n      if(!currentRunnable()) {\n        throw new Error('Spies must be created in a before function or a spec');\n      }\n      return runnableResources[currentRunnable().id].spies;\n    }});\n\n    this.spyOn = function() {\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\n    };\n\n    var suiteFactory = function(description) {\n      var suite = new j$.Suite({\n        env: self,\n        id: getNextSuiteId(),\n        description: description,\n        parentSuite: currentDeclarationSuite,\n        queueRunner: queueRunnerFactory,\n        onStart: suiteStarted,\n        expectationFactory: expectationFactory,\n        expectationResultFactory: expectationResultFactory,\n        runnablesExplictlySetGetter: runnablesExplictlySetGetter,\n        resultCallback: function(attrs) {\n          if (!suite.disabled) {\n            clearResourcesForRunnable(suite.id);\n          }\n          currentlyExecutingSuites.pop();\n          reporter.suiteDone(attrs);\n        }\n      });\n\n      runnableLookupTable[suite.id] = suite;\n      return suite;\n\n      function suiteStarted(suite) {\n        currentlyExecutingSuites.push(suite);\n        defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\n        reporter.suiteStarted(suite.result);\n      }\n    };\n\n    this.describe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    this.xdescribe = function(description, specDefinitions) {\n      var suite = this.describe(description, specDefinitions);\n      suite.disable();\n      return suite;\n    };\n\n    var focusedRunnables = [];\n\n    this.fdescribe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.isFocused = true;\n\n      focusedRunnables.push(suite.id);\n      unfocusAncestor();\n      addSpecsToSuite(suite, specDefinitions);\n\n      return suite;\n    };\n\n    function addSpecsToSuite(suite, specDefinitions) {\n      var parentSuite = currentDeclarationSuite;\n      parentSuite.addChild(suite);\n      currentDeclarationSuite = suite;\n\n      var declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (e) {\n        declarationError = e;\n      }\n\n      if (declarationError) {\n        self.it('encountered a declaration exception', function() {\n          throw declarationError;\n        });\n      }\n\n      currentDeclarationSuite = parentSuite;\n    }\n\n    function findFocusedAncestor(suite) {\n      while (suite) {\n        if (suite.isFocused) {\n          return suite.id;\n        }\n        suite = suite.parentSuite;\n      }\n\n      return null;\n    }\n\n    function unfocusAncestor() {\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n      if (focusedAncestor) {\n        for (var i = 0; i < focusedRunnables.length; i++) {\n          if (focusedRunnables[i] === focusedAncestor) {\n            focusedRunnables.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    var runnablesExplictlySet = false;\n\n    var runnablesExplictlySetGetter = function(){\n      return runnablesExplictlySet;\n    };\n\n    var specFactory = function(description, fn, suite, timeout) {\n      totalSpecsDefined++;\n      var spec = new j$.Spec({\n        id: getNextSpecId(),\n        beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\n        expectationFactory: expectationFactory,\n        resultCallback: specResultCallback,\n        getSpecName: function(spec) {\n          return getSpecName(spec, suite);\n        },\n        onStart: specStarted,\n        description: description,\n        expectationResultFactory: expectationResultFactory,\n        queueRunnerFactory: queueRunnerFactory,\n        userContext: function() { return suite.clonedSharedUserContext(); },\n        queueableFn: {\n          fn: fn,\n          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n        }\n      });\n\n      runnableLookupTable[spec.id] = spec;\n\n      if (!self.specFilter(spec)) {\n        spec.disable();\n      }\n\n      return spec;\n\n      function specResultCallback(result) {\n        clearResourcesForRunnable(spec.id);\n        currentSpec = null;\n        reporter.specDone(result);\n      }\n\n      function specStarted(spec) {\n        currentSpec = spec;\n        defaultResourcesForRunnable(spec.id, suite.id);\n        reporter.specStarted(spec.result);\n      }\n    };\n\n    this.it = function(description, fn, timeout) {\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      currentDeclarationSuite.addChild(spec);\n      return spec;\n    };\n\n    this.xit = function() {\n      var spec = this.it.apply(this, arguments);\n      spec.pend();\n      return spec;\n    };\n\n    this.fit = function(){\n      var spec = this.it.apply(this, arguments);\n\n      focusedRunnables.push(spec.id);\n      unfocusAncestor();\n      return spec;\n    };\n\n    this.expect = function(actual) {\n      if (!currentRunnable()) {\n        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n      }\n\n      return currentRunnable().expect(actual);\n    };\n\n    this.beforeEach = function(beforeEachFunction, timeout) {\n      currentDeclarationSuite.beforeEach({\n        fn: beforeEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.beforeAll = function(beforeAllFunction, timeout) {\n      currentDeclarationSuite.beforeAll({\n        fn: beforeAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterEach = function(afterEachFunction, timeout) {\n      currentDeclarationSuite.afterEach({\n        fn: afterEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterAll = function(afterAllFunction, timeout) {\n      currentDeclarationSuite.afterAll({\n        fn: afterAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.pending = function(message) {\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\n      if(message) {\n        fullMessage += message;\n      }\n      throw fullMessage;\n    };\n\n    this.fail = function(error) {\n      var message = 'Failed';\n      if (error) {\n        message += ': ';\n        message += error.message || error;\n      }\n\n      currentRunnable().addExpectationResult(false, {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        message: message,\n        error: error && error.message ? error : null\n      });\n    };\n  }\n\n  return Env;\n};\n\ngetJasmineRequireObj().JsApiReporter = function() {\n\n  var noopTimer = {\n    start: function(){},\n    elapsed: function(){ return 0; }\n  };\n\n  function JsApiReporter(options) {\n    var timer = options.timer || noopTimer,\n        status = 'loaded';\n\n    this.started = false;\n    this.finished = false;\n\n    this.jasmineStarted = function() {\n      this.started = true;\n      status = 'started';\n      timer.start();\n    };\n\n    var executionTime;\n\n    this.jasmineDone = function() {\n      this.finished = true;\n      executionTime = timer.elapsed();\n      status = 'done';\n    };\n\n    this.status = function() {\n      return status;\n    };\n\n    var suites = [],\n      suites_hash = {};\n\n    this.suiteStarted = function(result) {\n      suites_hash[result.id] = result;\n    };\n\n    this.suiteDone = function(result) {\n      storeSuite(result);\n    };\n\n    this.suiteResults = function(index, length) {\n      return suites.slice(index, index + length);\n    };\n\n    function storeSuite(result) {\n      suites.push(result);\n      suites_hash[result.id] = result;\n    }\n\n    this.suites = function() {\n      return suites_hash;\n    };\n\n    var specs = [];\n\n    this.specDone = function(result) {\n      specs.push(result);\n    };\n\n    this.specResults = function(index, length) {\n      return specs.slice(index, index + length);\n    };\n\n    this.specs = function() {\n      return specs;\n    };\n\n    this.executionTime = function() {\n      return executionTime;\n    };\n\n  }\n\n  return JsApiReporter;\n};\n\ngetJasmineRequireObj().CallTracker = function() {\n\n  function CallTracker() {\n    var calls = [];\n\n    this.track = function(context) {\n      calls.push(context);\n    };\n\n    this.any = function() {\n      return !!calls.length;\n    };\n\n    this.count = function() {\n      return calls.length;\n    };\n\n    this.argsFor = function(index) {\n      var call = calls[index];\n      return call ? call.args : [];\n    };\n\n    this.all = function() {\n      return calls;\n    };\n\n    this.allArgs = function() {\n      var callArgs = [];\n      for(var i = 0; i < calls.length; i++){\n        callArgs.push(calls[i].args);\n      }\n\n      return callArgs;\n    };\n\n    this.first = function() {\n      return calls[0];\n    };\n\n    this.mostRecent = function() {\n      return calls[calls.length - 1];\n    };\n\n    this.reset = function() {\n      calls = [];\n    };\n  }\n\n  return CallTracker;\n};\n\ngetJasmineRequireObj().Clock = function() {\n  function Clock(global, delayedFunctionScheduler, mockDate) {\n    var self = this,\n      realTimingFunctions = {\n        setTimeout: global.setTimeout,\n        clearTimeout: global.clearTimeout,\n        setInterval: global.setInterval,\n        clearInterval: global.clearInterval\n      },\n      fakeTimingFunctions = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n        setInterval: setInterval,\n        clearInterval: clearInterval\n      },\n      installed = false,\n      timer;\n\n\n    self.install = function() {\n      replace(global, fakeTimingFunctions);\n      timer = fakeTimingFunctions;\n      installed = true;\n\n      return self;\n    };\n\n    self.uninstall = function() {\n      delayedFunctionScheduler.reset();\n      mockDate.uninstall();\n      replace(global, realTimingFunctions);\n\n      timer = realTimingFunctions;\n      installed = false;\n    };\n\n    self.mockDate = function(initialDate) {\n      mockDate.install(initialDate);\n    };\n\n    self.setTimeout = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\n        }\n        return timer.setTimeout(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\n    };\n\n    self.setInterval = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\n        }\n        return timer.setInterval(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\n    };\n\n    self.clearTimeout = function(id) {\n      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\n    };\n\n    self.clearInterval = function(id) {\n      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\n    };\n\n    self.tick = function(millis) {\n      if (installed) {\n        mockDate.tick(millis);\n        delayedFunctionScheduler.tick(millis);\n      } else {\n        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\n      }\n    };\n\n    return self;\n\n    function legacyIE() {\n      //if these methods are polyfilled, apply will be present\n      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\n    }\n\n    function replace(dest, source) {\n      for (var prop in source) {\n        dest[prop] = source[prop];\n      }\n    }\n\n    function setTimeout(fn, delay) {\n      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\n    }\n\n    function clearTimeout(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function setInterval(fn, interval) {\n      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\n    }\n\n    function clearInterval(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function argSlice(argsObj, n) {\n      return Array.prototype.slice.call(argsObj, n);\n    }\n  }\n\n  return Clock;\n};\n\ngetJasmineRequireObj().DelayedFunctionScheduler = function() {\n  function DelayedFunctionScheduler() {\n    var self = this;\n    var scheduledLookup = [];\n    var scheduledFunctions = {};\n    var currentTime = 0;\n    var delayedFnCount = 0;\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      var endTime = currentTime + millis;\n\n      runScheduledFunctions(endTime);\n      currentTime = endTime;\n    };\n\n    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\n      var f;\n      if (typeof(funcToCall) === 'string') {\n        /* jshint evil: true */\n        f = function() { return eval(funcToCall); };\n        /* jshint evil: false */\n      } else {\n        f = funcToCall;\n      }\n\n      millis = millis || 0;\n      timeoutKey = timeoutKey || ++delayedFnCount;\n      runAtMillis = runAtMillis || (currentTime + millis);\n\n      var funcToSchedule = {\n        runAtMillis: runAtMillis,\n        funcToCall: f,\n        recurring: recurring,\n        params: params,\n        timeoutKey: timeoutKey,\n        millis: millis\n      };\n\n      if (runAtMillis in scheduledFunctions) {\n        scheduledFunctions[runAtMillis].push(funcToSchedule);\n      } else {\n        scheduledFunctions[runAtMillis] = [funcToSchedule];\n        scheduledLookup.push(runAtMillis);\n        scheduledLookup.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      return timeoutKey;\n    };\n\n    self.removeFunctionWithId = function(timeoutKey) {\n      for (var runAtMillis in scheduledFunctions) {\n        var funcs = scheduledFunctions[runAtMillis];\n        var i = indexOfFirstToPass(funcs, function (func) {\n          return func.timeoutKey === timeoutKey;\n        });\n\n        if (i > -1) {\n          if (funcs.length === 1) {\n            delete scheduledFunctions[runAtMillis];\n            deleteFromLookup(runAtMillis);\n          } else {\n            funcs.splice(i, 1);\n          }\n\n          // intervals get rescheduled when executed, so there's never more\n          // than a single scheduled function with a given timeoutKey\n          break;\n        }\n      }\n    };\n\n    self.reset = function() {\n      currentTime = 0;\n      scheduledLookup = [];\n      scheduledFunctions = {};\n      delayedFnCount = 0;\n    };\n\n    return self;\n\n    function indexOfFirstToPass(array, testFn) {\n      var index = -1;\n\n      for (var i = 0; i < array.length; ++i) {\n        if (testFn(array[i])) {\n          index = i;\n          break;\n        }\n      }\n\n      return index;\n    }\n\n    function deleteFromLookup(key) {\n      var value = Number(key);\n      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\n        return millis === value;\n      });\n\n      if (i > -1) {\n        scheduledLookup.splice(i, 1);\n      }\n    }\n\n    function reschedule(scheduledFn) {\n      self.scheduleFunction(scheduledFn.funcToCall,\n        scheduledFn.millis,\n        scheduledFn.params,\n        true,\n        scheduledFn.timeoutKey,\n        scheduledFn.runAtMillis + scheduledFn.millis);\n    }\n\n    function forEachFunction(funcsToRun, callback) {\n      for (var i = 0; i < funcsToRun.length; ++i) {\n        callback(funcsToRun[i]);\n      }\n    }\n\n    function runScheduledFunctions(endTime) {\n      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\n        return;\n      }\n\n      do {\n        currentTime = scheduledLookup.shift();\n\n        var funcsToRun = scheduledFunctions[currentTime];\n        delete scheduledFunctions[currentTime];\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          if (funcToRun.recurring) {\n            reschedule(funcToRun);\n          }\n        });\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          funcToRun.funcToCall.apply(null, funcToRun.params || []);\n        });\n      } while (scheduledLookup.length > 0 &&\n              // checking first if we're out of time prevents setTimeout(0)\n              // scheduled in a funcToRun from forcing an extra iteration\n                 currentTime !== endTime  &&\n                 scheduledLookup[0] <= endTime);\n    }\n  }\n\n  return DelayedFunctionScheduler;\n};\n\ngetJasmineRequireObj().ExceptionFormatter = function() {\n  function ExceptionFormatter() {\n    this.message = function(error) {\n      var message = '';\n\n      if (error.name && error.message) {\n        message += error.name + ': ' + error.message;\n      } else {\n        message += error.toString() + ' thrown';\n      }\n\n      if (error.fileName || error.sourceURL) {\n        message += ' in ' + (error.fileName || error.sourceURL);\n      }\n\n      if (error.line || error.lineNumber) {\n        message += ' (line ' + (error.line || error.lineNumber) + ')';\n      }\n\n      return message;\n    };\n\n    this.stack = function(error) {\n      return error ? error.stack : null;\n    };\n  }\n\n  return ExceptionFormatter;\n};\n\ngetJasmineRequireObj().Expectation = function() {\n\n  function Expectation(options) {\n    this.util = options.util || { buildFailureMessage: function() {} };\n    this.customEqualityTesters = options.customEqualityTesters || [];\n    this.actual = options.actual;\n    this.addExpectationResult = options.addExpectationResult || function(){};\n    this.isNot = options.isNot;\n\n    var customMatchers = options.customMatchers || {};\n    for (var matcherName in customMatchers) {\n      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\n    }\n  }\n\n  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        expected = args.slice(0),\n        message = '';\n\n      args.unshift(this.actual);\n\n      var matcher = matcherFactory(this.util, this.customEqualityTesters),\n          matcherCompare = matcher.compare;\n\n      function defaultNegativeCompare() {\n        var result = matcher.compare.apply(null, args);\n        result.pass = !result.pass;\n        return result;\n      }\n\n      if (this.isNot) {\n        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\n      }\n\n      var result = matcherCompare.apply(null, args);\n\n      if (!result.pass) {\n        if (!result.message) {\n          args.unshift(this.isNot);\n          args.unshift(name);\n          message = this.util.buildFailureMessage.apply(null, args);\n        } else {\n          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\n            message = result.message();\n          } else {\n            message = result.message;\n          }\n        }\n      }\n\n      if (expected.length == 1) {\n        expected = expected[0];\n      }\n\n      // TODO: how many of these params are needed?\n      this.addExpectationResult(\n        result.pass,\n        {\n          matcherName: name,\n          passed: result.pass,\n          message: message,\n          actual: this.actual,\n          expected: expected // TODO: this may need to be arrayified/sliced\n        }\n      );\n    };\n  };\n\n  Expectation.addCoreMatchers = function(matchers) {\n    var prototype = Expectation.prototype;\n    for (var matcherName in matchers) {\n      var matcher = matchers[matcherName];\n      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\n    }\n  };\n\n  Expectation.Factory = function(options) {\n    options = options || {};\n\n    var expect = new Expectation(options);\n\n    // TODO: this would be nice as its own Object - NegativeExpectation\n    // TODO: copy instead of mutate options\n    options.isNot = true;\n    expect.not = new Expectation(options);\n\n    return expect;\n  };\n\n  return Expectation;\n};\n\n//TODO: expectation result may make more sense as a presentation of an expectation.\ngetJasmineRequireObj().buildExpectationResult = function() {\n  function buildExpectationResult(options) {\n    var messageFormatter = options.messageFormatter || function() {},\n      stackFormatter = options.stackFormatter || function() {};\n\n    var result = {\n      matcherName: options.matcherName,\n      message: message(),\n      stack: stack(),\n      passed: options.passed\n    };\n\n    if(!result.passed) {\n      result.expected = options.expected;\n      result.actual = options.actual;\n    }\n\n    return result;\n\n    function message() {\n      if (options.passed) {\n        return 'Passed.';\n      } else if (options.message) {\n        return options.message;\n      } else if (options.error) {\n        return messageFormatter(options.error);\n      }\n      return '';\n    }\n\n    function stack() {\n      if (options.passed) {\n        return '';\n      }\n\n      var error = options.error;\n      if (!error) {\n        try {\n          throw new Error(message());\n        } catch (e) {\n          error = e;\n        }\n      }\n      return stackFormatter(error);\n    }\n  }\n\n  return buildExpectationResult;\n};\n\ngetJasmineRequireObj().MockDate = function() {\n  function MockDate(global) {\n    var self = this;\n    var currentTime = 0;\n\n    if (!global || !global.Date) {\n      self.install = function() {};\n      self.tick = function() {};\n      self.uninstall = function() {};\n      return self;\n    }\n\n    var GlobalDate = global.Date;\n\n    self.install = function(mockDate) {\n      if (mockDate instanceof GlobalDate) {\n        currentTime = mockDate.getTime();\n      } else {\n        currentTime = new GlobalDate().getTime();\n      }\n\n      global.Date = FakeDate;\n    };\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      currentTime = currentTime + millis;\n    };\n\n    self.uninstall = function() {\n      currentTime = 0;\n      global.Date = GlobalDate;\n    };\n\n    createDateProperties();\n\n    return self;\n\n    function FakeDate() {\n      switch(arguments.length) {\n        case 0:\n          return new GlobalDate(currentTime);\n        case 1:\n          return new GlobalDate(arguments[0]);\n        case 2:\n          return new GlobalDate(arguments[0], arguments[1]);\n        case 3:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2]);\n        case 4:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);\n        case 5:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4]);\n        case 6:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5]);\n        default:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5], arguments[6]);\n      }\n    }\n\n    function createDateProperties() {\n      FakeDate.prototype = GlobalDate.prototype;\n\n      FakeDate.now = function() {\n        if (GlobalDate.now) {\n          return currentTime;\n        } else {\n          throw new Error('Browser does not support Date.now()');\n        }\n      };\n\n      FakeDate.toSource = GlobalDate.toSource;\n      FakeDate.toString = GlobalDate.toString;\n      FakeDate.parse = GlobalDate.parse;\n      FakeDate.UTC = GlobalDate.UTC;\n    }\n\t}\n\n  return MockDate;\n};\n\ngetJasmineRequireObj().pp = function(j$) {\n\n  function PrettyPrinter() {\n    this.ppNestLevel_ = 0;\n    this.seen = [];\n  }\n\n  PrettyPrinter.prototype.format = function(value) {\n    this.ppNestLevel_++;\n    try {\n      if (j$.util.isUndefined(value)) {\n        this.emitScalar('undefined');\n      } else if (value === null) {\n        this.emitScalar('null');\n      } else if (value === 0 && 1/value === -Infinity) {\n        this.emitScalar('-0');\n      } else if (value === j$.getGlobal()) {\n        this.emitScalar('<global>');\n      } else if (value.jasmineToString) {\n        this.emitScalar(value.jasmineToString());\n      } else if (typeof value === 'string') {\n        this.emitString(value);\n      } else if (j$.isSpy(value)) {\n        this.emitScalar('spy on ' + value.and.identity());\n      } else if (value instanceof RegExp) {\n        this.emitScalar(value.toString());\n      } else if (typeof value === 'function') {\n        this.emitScalar('Function');\n      } else if (typeof value.nodeType === 'number') {\n        this.emitScalar('HTMLNode');\n      } else if (value instanceof Date) {\n        this.emitScalar('Date(' + value + ')');\n      } else if (j$.util.arrayContains(this.seen, value)) {\n        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\n      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\n        this.seen.push(value);\n        if (j$.isArray_(value)) {\n          this.emitArray(value);\n        } else {\n          this.emitObject(value);\n        }\n        this.seen.pop();\n      } else {\n        this.emitScalar(value.toString());\n      }\n    } finally {\n      this.ppNestLevel_--;\n    }\n  };\n\n  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\n    for (var property in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }\n      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&\n          obj.__lookupGetter__(property) !== null) : false);\n    }\n  };\n\n  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;\n\n  function StringPrettyPrinter() {\n    PrettyPrinter.call(this);\n\n    this.string = '';\n  }\n\n  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);\n\n  StringPrettyPrinter.prototype.emitScalar = function(value) {\n    this.append(value);\n  };\n\n  StringPrettyPrinter.prototype.emitString = function(value) {\n    this.append('\\'' + value + '\\'');\n  };\n\n  StringPrettyPrinter.prototype.emitArray = function(array) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Array');\n      return;\n    }\n    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    this.append('[ ');\n    for (var i = 0; i < length; i++) {\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format(array[i]);\n    }\n    if(array.length > length){\n      this.append(', ...');\n    }\n    this.append(' ]');\n  };\n\n  StringPrettyPrinter.prototype.emitObject = function(obj) {\n    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : 'null';\n    this.append(constructorName);\n\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      return;\n    }\n\n    var self = this;\n    this.append('({ ');\n    var first = true;\n\n    this.iterateObject(obj, function(property, isGetter) {\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.append(property);\n      self.append(': ');\n      if (isGetter) {\n        self.append('<getter>');\n      } else {\n        self.format(obj[property]);\n      }\n    });\n\n    this.append(' })');\n  };\n\n  StringPrettyPrinter.prototype.append = function(value) {\n    this.string += value;\n  };\n\n  return function(value) {\n    var stringPrettyPrinter = new StringPrettyPrinter();\n    stringPrettyPrinter.format(value);\n    return stringPrettyPrinter.string;\n  };\n};\n\ngetJasmineRequireObj().QueueRunner = function(j$) {\n\n  function once(fn) {\n    var called = false;\n    return function() {\n      if (!called) {\n        called = true;\n        fn();\n      }\n    };\n  }\n\n  function QueueRunner(attrs) {\n    this.queueableFns = attrs.queueableFns || [];\n    this.onComplete = attrs.onComplete || function() {};\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\n    this.onException = attrs.onException || function() {};\n    this.catchException = attrs.catchException || function() { return true; };\n    this.userContext = attrs.userContext || {};\n    this.timer = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\n    this.fail = attrs.fail || function() {};\n  }\n\n  QueueRunner.prototype.execute = function() {\n    this.run(this.queueableFns, 0);\n  };\n\n  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {\n    var length = queueableFns.length,\n      self = this,\n      iterativeIndex;\n\n\n    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\n      var queueableFn = queueableFns[iterativeIndex];\n      if (queueableFn.fn.length > 0) {\n        attemptAsync(queueableFn);\n        return;\n      } else {\n        attemptSync(queueableFn);\n      }\n    }\n\n    var runnerDone = iterativeIndex >= length;\n\n    if (runnerDone) {\n      this.clearStack(this.onComplete);\n    }\n\n    function attemptSync(queueableFn) {\n      try {\n        queueableFn.fn.call(self.userContext);\n      } catch (e) {\n        handleException(e, queueableFn);\n      }\n    }\n\n    function attemptAsync(queueableFn) {\n      var clearTimeout = function () {\n          Function.prototype.apply.apply(self.timer.clearTimeout, [j$.getGlobal(), [timeoutId]]);\n        },\n        next = once(function () {\n          clearTimeout(timeoutId);\n          self.run(queueableFns, iterativeIndex + 1);\n        }),\n        timeoutId;\n\n      next.fail = function() {\n        self.fail.apply(null, arguments);\n        next();\n      };\n\n      if (queueableFn.timeout) {\n        timeoutId = Function.prototype.apply.apply(self.timer.setTimeout, [j$.getGlobal(), [function() {\n          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');\n          onException(error, queueableFn);\n          next();\n        }, queueableFn.timeout()]]);\n      }\n\n      try {\n        queueableFn.fn.call(self.userContext, next);\n      } catch (e) {\n        handleException(e, queueableFn);\n        next();\n      }\n    }\n\n    function onException(e, queueableFn) {\n      self.onException(e);\n    }\n\n    function handleException(e, queueableFn) {\n      onException(e, queueableFn);\n      if (!self.catchException(e)) {\n        //TODO: set a var when we catch an exception and\n        //use a finally block to close the loop in a nice way..\n        throw e;\n      }\n    }\n  };\n\n  return QueueRunner;\n};\n\ngetJasmineRequireObj().ReportDispatcher = function() {\n  function ReportDispatcher(methods) {\n\n    var dispatchedMethods = methods || [];\n\n    for (var i = 0; i < dispatchedMethods.length; i++) {\n      var method = dispatchedMethods[i];\n      this[method] = (function(m) {\n        return function() {\n          dispatch(m, arguments);\n        };\n      }(method));\n    }\n\n    var reporters = [];\n\n    this.addReporter = function(reporter) {\n      reporters.push(reporter);\n    };\n\n    return this;\n\n    function dispatch(method, args) {\n      for (var i = 0; i < reporters.length; i++) {\n        var reporter = reporters[i];\n        if (reporter[method]) {\n          reporter[method].apply(reporter, args);\n        }\n      }\n    }\n  }\n\n  return ReportDispatcher;\n};\n\n\ngetJasmineRequireObj().SpyRegistry = function(j$) {\n\n  function SpyRegistry(options) {\n    options = options || {};\n    var currentSpies = options.currentSpies || function() { return []; };\n\n    this.spyOn = function(obj, methodName) {\n      if (j$.util.isUndefined(obj)) {\n        throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\n      }\n\n      if (j$.util.isUndefined(methodName)) {\n        throw new Error('No method name supplied');\n      }\n\n      if (j$.util.isUndefined(obj[methodName])) {\n        throw new Error(methodName + '() method does not exist');\n      }\n\n      if (obj[methodName] && j$.isSpy(obj[methodName])) {\n        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\n        throw new Error(methodName + ' has already been spied upon');\n      }\n\n      var spy = j$.createSpy(methodName, obj[methodName]);\n\n      currentSpies().push({\n        spy: spy,\n        baseObj: obj,\n        methodName: methodName,\n        originalValue: obj[methodName]\n      });\n\n      obj[methodName] = spy;\n\n      return spy;\n    };\n\n    this.clearSpies = function() {\n      var spies = currentSpies();\n      for (var i = 0; i < spies.length; i++) {\n        var spyEntry = spies[i];\n        spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\n      }\n    };\n  }\n\n  return SpyRegistry;\n};\n\ngetJasmineRequireObj().SpyStrategy = function() {\n\n  function SpyStrategy(options) {\n    options = options || {};\n\n    var identity = options.name || 'unknown',\n        originalFn = options.fn || function() {},\n        getSpy = options.getSpy || function() {},\n        plan = function() {};\n\n    this.identity = function() {\n      return identity;\n    };\n\n    this.exec = function() {\n      return plan.apply(this, arguments);\n    };\n\n    this.callThrough = function() {\n      plan = originalFn;\n      return getSpy();\n    };\n\n    this.returnValue = function(value) {\n      plan = function() {\n        return value;\n      };\n      return getSpy();\n    };\n\n    this.returnValues = function() {\n      var values = Array.prototype.slice.call(arguments);\n      plan = function () {\n        return values.shift();\n      };\n      return getSpy();\n    };\n\n    this.throwError = function(something) {\n      var error = (something instanceof Error) ? something : new Error(something);\n      plan = function() {\n        throw error;\n      };\n      return getSpy();\n    };\n\n    this.callFake = function(fn) {\n      plan = fn;\n      return getSpy();\n    };\n\n    this.stub = function(fn) {\n      plan = function() {};\n      return getSpy();\n    };\n  }\n\n  return SpyStrategy;\n};\n\ngetJasmineRequireObj().Suite = function() {\n  function Suite(attrs) {\n    this.env = attrs.env;\n    this.id = attrs.id;\n    this.parentSuite = attrs.parentSuite;\n    this.description = attrs.description;\n    this.onStart = attrs.onStart || function() {};\n    this.resultCallback = attrs.resultCallback || function() {};\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\n    this.expectationFactory = attrs.expectationFactory;\n    this.expectationResultFactory = attrs.expectationResultFactory;\n    this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\n\n    this.beforeFns = [];\n    this.afterFns = [];\n    this.beforeAllFns = [];\n    this.afterAllFns = [];\n    this.queueRunner = attrs.queueRunner || function() {};\n    this.disabled = false;\n\n    this.children = [];\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: []\n    };\n  }\n\n  Suite.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Suite.prototype.getFullName = function() {\n    var fullName = this.description;\n    for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\n      if (parentSuite.parentSuite) {\n        fullName = parentSuite.description + ' ' + fullName;\n      }\n    }\n    return fullName;\n  };\n\n  Suite.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Suite.prototype.beforeEach = function(fn) {\n    this.beforeFns.unshift(fn);\n  };\n\n  Suite.prototype.beforeAll = function(fn) {\n    this.beforeAllFns.push(fn);\n  };\n\n  Suite.prototype.afterEach = function(fn) {\n    this.afterFns.unshift(fn);\n  };\n\n  Suite.prototype.afterAll = function(fn) {\n    this.afterAllFns.push(fn);\n  };\n\n  Suite.prototype.addChild = function(child) {\n    this.children.push(child);\n  };\n\n  Suite.prototype.status = function() {\n    if (this.disabled) {\n      return 'disabled';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'finished';\n    }\n  };\n\n  Suite.prototype.execute = function(onComplete) {\n    var self = this;\n\n    this.onStart(this);\n\n    if (this.disabled) {\n      complete();\n      return;\n    }\n\n    var allFns = [];\n\n    for (var i = 0; i < this.children.length; i++) {\n      allFns.push(wrapChildAsAsync(this.children[i]));\n    }\n\n    if (this.isExecutable()) {\n      allFns = this.beforeAllFns.concat(allFns);\n      allFns = allFns.concat(this.afterAllFns);\n    }\n\n    this.queueRunner({\n      queueableFns: allFns,\n      onComplete: complete,\n      userContext: this.sharedUserContext(),\n      onException: function() { self.onException.apply(self, arguments); }\n    });\n\n    function complete() {\n      self.result.status = self.status();\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n\n    function wrapChildAsAsync(child) {\n      return { fn: function(done) { child.execute(done); } };\n    }\n  };\n\n  Suite.prototype.isExecutable = function() {\n    var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\n    return !runnablesExplicitlySet && hasExecutableChild(this.children);\n  };\n\n  Suite.prototype.sharedUserContext = function() {\n    if (!this.sharedContext) {\n      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\n    }\n\n    return this.sharedContext;\n  };\n\n  Suite.prototype.clonedSharedUserContext = function() {\n    return clone(this.sharedUserContext());\n  };\n\n  Suite.prototype.onException = function() {\n    if(isAfterAll(this.children)) {\n      var data = {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: arguments[0]\n      };\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.onException.apply(child, arguments);\n      }\n    }\n  };\n\n  Suite.prototype.addExpectationResult = function () {\n    if(isAfterAll(this.children) && isFailure(arguments)){\n      var data = arguments[1];\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.addExpectationResult.apply(child, arguments);\n      }\n    }\n  };\n\n  function isAfterAll(children) {\n    return children && children[0].result.status;\n  }\n\n  function isFailure(args) {\n    return !args[0];\n  }\n\n  function hasExecutableChild(children) {\n    var foundActive = false;\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].isExecutable()) {\n        foundActive = true;\n        break;\n      }\n    }\n    return foundActive;\n  }\n\n  function clone(obj) {\n    var clonedObj = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        clonedObj[prop] = obj[prop];\n      }\n    }\n\n    return clonedObj;\n  }\n\n  return Suite;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Suite = jasmineRequire.Suite;\n}\n\ngetJasmineRequireObj().Timer = function() {\n  var defaultNow = (function(Date) {\n    return function() { return new Date().getTime(); };\n  })(Date);\n\n  function Timer(options) {\n    options = options || {};\n\n    var now = options.now || defaultNow,\n      startTime;\n\n    this.start = function() {\n      startTime = now();\n    };\n\n    this.elapsed = function() {\n      return now() - startTime;\n    };\n  }\n\n  return Timer;\n};\n\ngetJasmineRequireObj().Any = function() {\n\n  function Any(expectedObject) {\n    this.expectedObject = expectedObject;\n  }\n\n  Any.prototype.asymmetricMatch = function(other) {\n    if (this.expectedObject == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.expectedObject == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.expectedObject == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.expectedObject == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.expectedObject == Boolean) {\n      return typeof other == 'boolean';\n    }\n\n    return other instanceof this.expectedObject;\n  };\n\n  Any.prototype.jasmineToString = function() {\n    return '<jasmine.any(' + this.expectedObject + ')>';\n  };\n\n  return Any;\n};\n\ngetJasmineRequireObj().Anything = function(j$) {\n\n  function Anything() {}\n\n  Anything.prototype.asymmetricMatch = function(other) {\n    return !j$.util.isUndefined(other) && other !== null;\n  };\n\n  Anything.prototype.jasmineToString = function() {\n    return '<jasmine.anything>';\n  };\n\n  return Anything;\n};\n\ngetJasmineRequireObj().ArrayContaining = function(j$) {\n  function ArrayContaining(sample) {\n    this.sample = sample;\n  }\n\n  ArrayContaining.prototype.asymmetricMatch = function(other) {\n    var className = Object.prototype.toString.call(this.sample);\n    if (className !== '[object Array]') { throw new Error('You must provide an array to arrayContaining, not \\'' + this.sample + '\\'.'); }\n\n    for (var i = 0; i < this.sample.length; i++) {\n      var item = this.sample[i];\n      if (!j$.matchersUtil.contains(other, item)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ArrayContaining.prototype.jasmineToString = function () {\n    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';\n  };\n\n  return ArrayContaining;\n};\n\ngetJasmineRequireObj().ObjectContaining = function(j$) {\n\n  function ObjectContaining(sample) {\n    this.sample = sample;\n  }\n\n  ObjectContaining.prototype.asymmetricMatch = function(other) {\n    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\n\n    for (var property in this.sample) {\n      if (!Object.prototype.hasOwnProperty.call(other, property) ||\n          !j$.matchersUtil.equals(this.sample[property], other[property])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ObjectContaining.prototype.jasmineToString = function() {\n    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\n  };\n\n  return ObjectContaining;\n};\n\ngetJasmineRequireObj().StringMatching = function(j$) {\n\n  function StringMatching(expected) {\n    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    this.regexp = new RegExp(expected);\n  }\n\n  StringMatching.prototype.asymmetricMatch = function(other) {\n    return this.regexp.test(other);\n  };\n\n  StringMatching.prototype.jasmineToString = function() {\n    return '<jasmine.stringMatching(' + this.regexp + ')>';\n  };\n\n  return StringMatching;\n};\n\ngetJasmineRequireObj().matchersUtil = function(j$) {\n  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\n\n  return {\n    equals: function(a, b, customTesters) {\n      customTesters = customTesters || [];\n\n      return eq(a, b, [], [], customTesters);\n    },\n\n    contains: function(haystack, needle, customTesters) {\n      customTesters = customTesters || [];\n\n      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\n        (!!haystack && !haystack.indexOf))\n      {\n        for (var i = 0; i < haystack.length; i++) {\n          if (eq(haystack[i], needle, [], [], customTesters)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      return !!haystack && haystack.indexOf(needle) >= 0;\n    },\n\n    buildFailureMessage: function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        matcherName = args[0],\n        isNot = args[1],\n        actual = args[2],\n        expected = args.slice(3),\n        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n\n      var message = 'Expected ' +\n        j$.pp(actual) +\n        (isNot ? ' not ' : ' ') +\n        englishyPredicate;\n\n      if (expected.length > 0) {\n        for (var i = 0; i < expected.length; i++) {\n          if (i > 0) {\n            message += ',';\n          }\n          message += ' ' + j$.pp(expected[i]);\n        }\n      }\n\n      return message + '.';\n    }\n  };\n\n  function isAsymmetric(obj) {\n    return obj && j$.isA_('Function', obj.asymmetricMatch);\n  }\n\n  function asymmetricMatch(a, b) {\n    var asymmetricA = isAsymmetric(a),\n        asymmetricB = isAsymmetric(b);\n\n    if (asymmetricA && asymmetricB) {\n      return undefined;\n    }\n\n    if (asymmetricA) {\n      return a.asymmetricMatch(b);\n    }\n\n    if (asymmetricB) {\n      return b.asymmetricMatch(a);\n    }\n  }\n\n  // Equality function lovingly adapted from isEqual in\n  //   [Underscore](http://underscorejs.org)\n  function eq(a, b, aStack, bStack, customTesters) {\n    var result = true;\n\n    var asymmetricResult = asymmetricMatch(a, b);\n    if (!j$.util.isUndefined(asymmetricResult)) {\n      return asymmetricResult;\n    }\n\n    for (var i = 0; i < customTesters.length; i++) {\n      var customTesterResult = customTesters[i](a, b);\n      if (!j$.util.isUndefined(customTesterResult)) {\n        return customTesterResult;\n      }\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n      return a.message == b.message;\n    }\n\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    // A strict comparison is necessary because `null == undefined`.\n    if (a === null || b === null) { return a === b; }\n    var className = Object.prototype.toString.call(a);\n    if (className != Object.prototype.toString.call(b)) { return false; }\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n          a.global == b.global &&\n          a.multiline == b.multiline &&\n          a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n\n    var aIsDomNode = j$.isDomNode(a);\n    var bIsDomNode = j$.isDomNode(b);\n    if (aIsDomNode && bIsDomNode) {\n      // At first try to use DOM3 method isEqualNode\n      if (a.isEqualNode) {\n        return a.isEqualNode(b);\n      }\n      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\n      var aIsElement = a instanceof Element;\n      var bIsElement = b instanceof Element;\n      if (aIsElement && bIsElement) {\n        return a.outerHTML == b.outerHTML;\n      }\n      if (aIsElement || bIsElement) {\n        return false;\n      }\n      return a.innerText == b.innerText && a.textContent == b.textContent;\n    }\n    if (aIsDomNode || bIsDomNode) {\n      return false;\n    }\n\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) { return bStack[length] == b; }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0;\n    // Recursively compare objects and arrays.\n    // Compare array lengths to determine if a deep comparison is necessary.\n    if (className == '[object Array]' && a.length !== b.length) {\n      result = false;\n    }\n\n    if (result) {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(isFunction(aCtor) && (aCtor instanceof aCtor) &&\n        isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (has(b, key) && !(size--)) { break; }\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n\n    return result;\n\n    function has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n  }\n};\n\ngetJasmineRequireObj().toBe = function() {\n  function toBe() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual === expected\n        };\n      }\n    };\n  }\n\n  return toBe;\n};\n\ngetJasmineRequireObj().toBeCloseTo = function() {\n\n  function toBeCloseTo() {\n    return {\n      compare: function(actual, expected, precision) {\n        if (precision !== 0) {\n          precision = precision || 2;\n        }\n\n        return {\n          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)\n        };\n      }\n    };\n  }\n\n  return toBeCloseTo;\n};\n\ngetJasmineRequireObj().toBeDefined = function() {\n  function toBeDefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: (void 0 !== actual)\n        };\n      }\n    };\n  }\n\n  return toBeDefined;\n};\n\ngetJasmineRequireObj().toBeFalsy = function() {\n  function toBeFalsy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!!actual\n        };\n      }\n    };\n  }\n\n  return toBeFalsy;\n};\n\ngetJasmineRequireObj().toBeGreaterThan = function() {\n\n  function toBeGreaterThan() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual > expected\n        };\n      }\n    };\n  }\n\n  return toBeGreaterThan;\n};\n\n\ngetJasmineRequireObj().toBeLessThan = function() {\n  function toBeLessThan() {\n    return {\n\n      compare: function(actual, expected) {\n        return {\n          pass: actual < expected\n        };\n      }\n    };\n  }\n\n  return toBeLessThan;\n};\ngetJasmineRequireObj().toBeNaN = function(j$) {\n\n  function toBeNaN() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual !== actual)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual not to be NaN.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBeNaN;\n};\n\ngetJasmineRequireObj().toBeNull = function() {\n\n  function toBeNull() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: actual === null\n        };\n      }\n    };\n  }\n\n  return toBeNull;\n};\n\ngetJasmineRequireObj().toBeTruthy = function() {\n\n  function toBeTruthy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!actual\n        };\n      }\n    };\n  }\n\n  return toBeTruthy;\n};\n\ngetJasmineRequireObj().toBeUndefined = function() {\n\n  function toBeUndefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: void 0 === actual\n        };\n      }\n    };\n  }\n\n  return toBeUndefined;\n};\n\ngetJasmineRequireObj().toContain = function() {\n  function toContain(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n\n        return {\n          pass: util.contains(actual, expected, customEqualityTesters)\n        };\n      }\n    };\n  }\n\n  return toContain;\n};\n\ngetJasmineRequireObj().toEqual = function() {\n\n  function toEqual(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n        var result = {\n          pass: false\n        };\n\n        result.pass = util.equals(actual, expected, customEqualityTesters);\n\n        return result;\n      }\n    };\n  }\n\n  return toEqual;\n};\n\ngetJasmineRequireObj().toHaveBeenCalled = function(j$) {\n\n  function toHaveBeenCalled() {\n    return {\n      compare: function(actual) {\n        var result = {};\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (arguments.length > 1) {\n          throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\n        }\n\n        result.pass = actual.calls.any();\n\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity() + ' not to have been called.' :\n          'Expected spy ' + actual.and.identity() + ' to have been called.';\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalled;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\n\n  function toHaveBeenCalledWith(util, customEqualityTesters) {\n    return {\n      compare: function() {\n        var args = Array.prototype.slice.call(arguments, 0),\n          actual = args[0],\n          expectedArgs = args.slice(1),\n          result = { pass: false };\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (!actual.calls.any()) {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\n          return result;\n        }\n\n        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\n          result.pass = true;\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\n        } else {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledWith;\n};\n\ngetJasmineRequireObj().toMatch = function(j$) {\n\n  function toMatch() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n          throw new Error('Expected is not a String or a RegExp');\n        }\n\n        var regexp = new RegExp(expected);\n\n        return {\n          pass: regexp.test(actual)\n        };\n      }\n    };\n  }\n\n  return toMatch;\n};\n\ngetJasmineRequireObj().toThrow = function(j$) {\n\n  function toThrow(util) {\n    return {\n      compare: function(actual, expected) {\n        var result = { pass: false },\n          threw = false,\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          result.message = 'Expected function to throw an exception.';\n          return result;\n        }\n\n        if (arguments.length == 1) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\n\n          return result;\n        }\n\n        if (util.equals(thrown, expected)) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\n        } else {\n          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toThrow;\n};\n\ngetJasmineRequireObj().toThrowError = function(j$) {\n  function toThrowError (util) {\n    return {\n      compare: function(actual) {\n        var threw = false,\n          pass = {pass: true},\n          fail = {pass: false},\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        var errorMatcher = getMatcher.apply(null, arguments);\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          fail.message = 'Expected function to throw an Error.';\n          return fail;\n        }\n\n        if (!(thrown instanceof Error)) {\n          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\n          return fail;\n        }\n\n        if (errorMatcher.hasNoSpecifics()) {\n          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\n          return pass;\n        }\n\n        if (errorMatcher.matches(thrown)) {\n          pass.message = function() {\n            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\n          };\n          return pass;\n        } else {\n          fail.message = function() {\n            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\n              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\n          };\n          return fail;\n        }\n      }\n    };\n\n    function getMatcher() {\n      var expected = null,\n          errorType = null;\n\n      if (arguments.length == 2) {\n        expected = arguments[1];\n        if (isAnErrorType(expected)) {\n          errorType = expected;\n          expected = null;\n        }\n      } else if (arguments.length > 2) {\n        errorType = arguments[1];\n        expected = arguments[2];\n        if (!isAnErrorType(errorType)) {\n          throw new Error('Expected error type is not an Error.');\n        }\n      }\n\n      if (expected && !isStringOrRegExp(expected)) {\n        if (errorType) {\n          throw new Error('Expected error message is not a string or RegExp.');\n        } else {\n          throw new Error('Expected is not an Error, string, or RegExp.');\n        }\n      }\n\n      function messageMatch(message) {\n        if (typeof expected == 'string') {\n          return expected == message;\n        } else {\n          return expected.test(message);\n        }\n      }\n\n      return {\n        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\n        thrownDescription: function(thrown) {\n          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\n              thrownMessage = '';\n\n          if (expected) {\n            thrownMessage = ' with message ' + j$.pp(thrown.message);\n          }\n\n          return thrownName + thrownMessage;\n        },\n        messageDescription: function() {\n          if (expected === null) {\n            return '';\n          } else if (expected instanceof RegExp) {\n            return ' with a message matching ' + j$.pp(expected);\n          } else {\n            return ' with message ' + j$.pp(expected);\n          }\n        },\n        hasNoSpecifics: function() {\n          return expected === null && errorType === null;\n        },\n        matches: function(error) {\n          return (errorType === null || error.constructor === errorType) &&\n            (expected === null || messageMatch(error.message));\n        }\n      };\n    }\n\n    function isStringOrRegExp(potential) {\n      return potential instanceof RegExp || (typeof potential == 'string');\n    }\n\n    function isAnErrorType(type) {\n      if (typeof type !== 'function') {\n        return false;\n      }\n\n      var Surrogate = function() {};\n      Surrogate.prototype = type.prototype;\n      return (new Surrogate()) instanceof Error;\n    }\n  }\n\n  return toThrowError;\n};\n\ngetJasmineRequireObj().interface = function(jasmine, env) {\n  var jasmineInterface = {\n    describe: function(description, specDefinitions) {\n      return env.describe(description, specDefinitions);\n    },\n\n    xdescribe: function(description, specDefinitions) {\n      return env.xdescribe(description, specDefinitions);\n    },\n\n    fdescribe: function(description, specDefinitions) {\n      return env.fdescribe(description, specDefinitions);\n    },\n\n    it: function() {\n      return env.it.apply(env, arguments);\n    },\n\n    xit: function() {\n      return env.xit.apply(env, arguments);\n    },\n\n    fit: function() {\n      return env.fit.apply(env, arguments);\n    },\n\n    beforeEach: function() {\n      return env.beforeEach.apply(env, arguments);\n    },\n\n    afterEach: function() {\n      return env.afterEach.apply(env, arguments);\n    },\n\n    beforeAll: function() {\n      return env.beforeAll.apply(env, arguments);\n    },\n\n    afterAll: function() {\n      return env.afterAll.apply(env, arguments);\n    },\n\n    expect: function(actual) {\n      return env.expect(actual);\n    },\n\n    pending: function() {\n      return env.pending.apply(env, arguments);\n    },\n\n    fail: function() {\n      return env.fail.apply(env, arguments);\n    },\n\n    spyOn: function(obj, methodName) {\n      return env.spyOn(obj, methodName);\n    },\n\n    jsApiReporter: new jasmine.JsApiReporter({\n      timer: new jasmine.Timer()\n    }),\n\n    jasmine: jasmine\n  };\n\n  jasmine.addCustomEqualityTester = function(tester) {\n    env.addCustomEqualityTester(tester);\n  };\n\n  jasmine.addMatchers = function(matchers) {\n    return env.addMatchers(matchers);\n  };\n\n  jasmine.clock = function() {\n    return env.clock;\n  };\n\n  return jasmineInterface;\n};\n\ngetJasmineRequireObj().version = function() {\n  return '2.2.0';\n};\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/jasmine/client.js":"var ZuulReporter = require('../zuul');\nvar reporter = ZuulReporter(run);\n\nfunction ZuulJasmineReporter() {}\n\nfunction getFullSpecName(spec, separator) {\n    separator = separator || \" :: \";\n\n    function getFullSuiteName(suite) {\n        var parentSuitesNames = suite.parentSuite ? getFullSuiteName(suite.parentSuite) + separator : \"\";\n        return parentSuitesNames + suite.description;\n    }\n\n    return getFullSuiteName(spec.suite) + separator + spec.description;\n}\n\nfunction reportFirstSpecFailure(results) {\n    for (var i = 0; i < results.length; i++) {\n        if (!results[i].passed()) {\n            var result = results[i];\n            reporter.assertion({\n                result: false,\n                actual: result.actual,\n                expected: result.expected,\n                message: result.message,\n                error: result.trace,\n                source: result.trace.stack\n            });\n            return;\n        }\n    }\n\n}\n\nZuulJasmineReporter.prototype.reportRunnerResults = function () {\n    reporter.done();\n};\n\nZuulJasmineReporter.prototype.reportSpecStarting = function (spec) {\n    reporter.test({\n        name: getFullSpecName(spec)\n    });\n};\n\nZuulJasmineReporter.prototype.reportSpecResults = function (spec) {\n    var passed = !spec.results().failedCount;\n\n    if (!passed) {\n        reportFirstSpecFailure(spec.results_.items_);\n    }\n\n    reporter.test_end({\n        name: getFullSpecName(spec),\n        passed: passed\n    });\n};\n\nvar zuulJasmineReporter = new ZuulJasmineReporter();\nvar jasmineEnv = jasmine.getEnv();\n\njasmineEnv.addReporter(zuulJasmineReporter);\n\nfunction run() {\n    jasmineEnv.execute();\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/mocha/client.js":"var ZuulReporter = require('../zuul');\n\n// convert zuul mocha ui's to our ui\nvar ui_map = {\n  'mocha-bdd': 'bdd',\n  'mocha-qunit': 'qunit',\n  'mocha-tdd': 'tdd'\n};\n\nvar mocha_opt = {\n  ui: ui_map[zuul.ui],\n  reporter: function() {}\n};\n\nmocha.setup(mocha_opt);\n\n// whitelist the `msWDfn` global for Microsoft Edge\nif (/ Edge\\/[1-9][0-9]\\.[0-9]+$/.test(navigator.userAgent)) {\n  mocha.globals('msWDfn');\n}\n\nvar reporter = ZuulReporter(run);\n\nfunction getTitle(item) {\n  var title = item.title;\n  if(item.parent.title){\n    return getTitle(item.parent) + ' :: ' + title;\n  }\n\n  return title;\n}\n\nfunction run(err) {\n  if (err) {\n    return reporter.done(err);\n  }\n\n  var harness = mocha;\n  if (harness.checkLeaks) {\n    harness.checkLeaks();\n  }\n\n  var suite = harness.suite;\n  if (suite.suites.length === 0 && suite.tests.length === 0) {\n    return reporter.done(new Error('no tests defined'));\n  }\n\n  var runner = harness.run();\n\n  runner.on('fail', function(test, err) {\n    reporter.assertion({\n      result: false,\n      actual: undefined,\n      expected: undefined,\n      message: err.message,\n      error: err,\n      source: err.stack\n    });\n\n  });\n\n  runner.on('pending', function(test) {\n    reporter.skippedTest({\n      name: getTitle(test)\n    });\n  });\n\n  runner.on('test', function(test) {\n    reporter.test({\n      name: getTitle(test)\n    });\n  });\n\n  runner.on('test end', function(test) {\n    // mocha is broken\n    // https://github.com/defunctzombie/zuul/issues/35#issuecomment-32622253\n    if (test.state === undefined) {\n      return;\n    }\n\n    reporter.test_end({\n      name: test.title,\n      passed: test.state === 'passed',\n      duration: test.duration\n    });\n  });\n\n  runner.on('suite', function(suite) {\n    reporter.suite({\n      name: suite.title\n    });\n  });\n\n  runner.on('suite end', function(suite) {\n    reporter.suite_end(suite);\n  });\n\n  runner.on('end', function() {\n    reporter.done();\n  });\n\n  runner.on('error', function(err) {\n    reporter.done(err);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/qunit/client.js":"var ZuulReporter = require('../zuul');\n\nvar reporter = ZuulReporter(run);\n\nQUnit.config.autostart = false;\n\nQUnit.begin(function() {\n});\n\nQUnit.done(function(details) {\n    reporter.done();\n});\n\nQUnit.testStart(function(details) {\n    reporter.test({\n        name: details.name\n    });\n});\n\nQUnit.testDone(function(details) {\n    reporter.test_end({\n        name: details.name,\n        passed: details.passed\n    });\n});\n\nQUnit.log(function(details) {\n    reporter.assertion({\n        result: details.result,\n        expected: details.expected,\n        actual: details.actual,\n        message: details.message,\n        source: details.source\n    });\n});\n\nfunction run() {\n    QUnit.start();\n}\n","/home/travis/build/npmtest/node-npmtest-zuul/node_modules/zuul/frameworks/tape/client.js":"var finished = require('tap-finished');\nvar parser = require('tap-parser');\n\nvar ZuulReporter = require('../zuul');\n\nif (typeof global.console === 'undefined') {\n    global.console = {};\n}\n\nvar reporter = ZuulReporter(run);\nvar previous_test = undefined;\nvar assertions = 0;\nvar done = false;\nvar noMoreTests = false;\n\nvar parse_stream = parser();\n\nvar finished_stream = finished(function() {\n    done = true;\n    parse_stream.end();\n    reporter.done();\n});\n\nvar originalLog = global.console.log;\nglobal.console.log = function () {\n    var msg = arguments[0];\n\n    // do not write in a closed WriteStream\n    if (!done) {\n        parse_stream.write(msg + '\\n');\n        finished_stream.write(msg + '\\n');\n    }\n\n    // transfer log to original console,\n    // this shows the tap output in console\n    // and also let the user add console logs\n    if (typeof originalLog === 'function') {\n        return originalLog.apply(this, arguments);\n    }\n};\n\nparse_stream.on('comment', function(comment) {\n    // if we received 'plan' then no need to go further\n    if (noMoreTests) {\n        return;\n    }\n\n    endPreviousTestIfNeeded();\n\n    previous_test = {\n        name: comment\n    };\n\n    assertions = 0;\n\n    reporter.test({\n        name: comment\n    });\n});\n\nparse_stream.on('assert', function(assert) {\n    if (!assert.ok) {\n        assertions++;\n    }\n\n    reporter.assertion({\n        result: assert.ok,\n        expected: undefined,\n        actual: undefined,\n        message: assert.name || 'unnamed assert',\n        error: undefined,\n        stack: undefined\n    });\n});\n\nparse_stream.on('plan', function(plan) {\n    // starting here, we know the full tape suite is finished\n    endPreviousTestIfNeeded();\n    noMoreTests = true;\n});\n\nfunction endPreviousTestIfNeeded() {\n    if (previous_test) {\n        reporter.test_end({\n            passed: assertions === 0,\n            name: previous_test.name\n        });\n    }\n}\n\nfunction run() {\n    // tape tests already start by default\n    // I don't like this stuff, very annoying to interface with\n}\n"}